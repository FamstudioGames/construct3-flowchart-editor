<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Construct 3 Flowchart Editor</title>
    <style>
        :root {
            --bg-dark: #2b2b2b;
            --bg-panel: #1e1e1e;
            --bg-menu: #3c3c3c;
            --border: #3a3a3a;
            --accent: #0078d4;
            --accent-hover: #106ebe;
            --text-main: #e0e0e0;
            --text-dim: #888;
            --danger: #ff5555;
            --success: #4caf50;
            --warn: #ff9800;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; outline: none; }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-dark);
            color: var(--text-main);
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* --- UI COMPONENTS --- */
        .btn {
            padding: 8px 16px;
            background: var(--accent);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: background 0.2s;
        }
        .btn:hover:not(:disabled) { background: var(--accent-hover); }
        .btn:disabled { background: #555; cursor: not-allowed; opacity: 0.6; }
        .btn.small { padding: 4px 8px; font-size: 11px; }
        .btn.danger { background: var(--danger); }

        /* --- MENU BAR --- */
        #menu-bar {
            background: var(--bg-menu);
            height: 30px;
            display: flex;
            align-items: center;
            border-bottom: 1px solid #1e1e1e;
            user-select: none;
            z-index: 1000;
            font-size: 13px;
        }

        .menu-item {
            padding: 0 15px;
            height: 100%;
            display: flex;
            align-items: center;
            cursor: pointer;
            position: relative;
        }
        .menu-item:hover { background: #505050; }
        .menu-item.active { background: var(--accent) !important; }

        .dropdown {
            display: none;
            position: absolute;
            top: 30px; left: 0;
            background: #2d2d2d;
            border: 1px solid #454545;
            min-width: 200px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
            z-index: 1001;
        }
        .dropdown-item { padding: 8px 20px; cursor: pointer; color: var(--text-main); }
        .dropdown-item:hover:not(.disabled) { background: var(--accent); }
        .dropdown-item.disabled { opacity: 0.5; cursor: default; }
        .separator { height: 1px; background: #454545; margin: 4px 0; }

        /* --- SUBMENU --- */
        .dropdown-item {
            position: relative; /* Для позиционирования подменю */
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .dropdown-item .shortcut {
            color: #888;
            font-size: 11px;
            margin-left: 20px;
        }

        .dropdown-item .arrow {
            font-size: 10px;
            color: #aaa;
            margin-left: 10px;
        }

        /* Скрываем подменю по умолчанию */
        .submenu {
            display: none;
            position: absolute;
            left: 100%; /* Появляется справа от родителя */
            top: -5px;  /* Чуть выше для выравнивания */
            background: #2d2d2d;
            border: 1px solid #454545;
            min-width: 220px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
            z-index: 1002;
        }

        /* Показываем подменю при наведении на родительский пункт */
        .dropdown-item:hover > .submenu {
            display: block;
        }

        /* --- TOOLBAR --- */
        #toolbar {
            display: none;
            background: var(--bg-panel);
            padding: 8px;
            border-bottom: 1px solid var(--border);
            gap: 10px;
        }
        #toolbar.active { display: flex; }
        .toolbar-group { display: flex; gap: 5px; padding-right: 10px; border-right: 1px solid #555; }
        .toolbar-group:last-child { border: none; }

        /* --- MAIN AREA --- */
        #workspace {
            position: relative;
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        #canvas-container {
            flex: 1;
            position: relative;
            background: var(--bg-dark);
            overflow: hidden;
        }
        
        canvas { display: block; cursor: grab; }
        canvas:active { cursor: grabbing; }
        canvas.editing { cursor: default; }

        /* --- PROPERTIES PANEL --- */
        #properties-panel {
            width: 350px;
            background: var(--bg-panel);
            border-left: 1px solid var(--border);
            overflow-y: auto;
            padding: 15px;
            display: none;
            z-index: 40;
        }
        #properties-panel.active { display: block; }

        .prop-group { margin-bottom: 20px; padding-bottom: 20px; border-bottom: 1px solid var(--border); }
        .prop-group h3 { margin-bottom: 10px; color: var(--accent); font-size: 14px; }
        .prop-row { margin-bottom: 10px; }
        .prop-row label { display: block; margin-bottom: 5px; font-size: 12px; color: var(--text-dim); }
        
        input[type="text"], input[type="number"], textarea, select {
            width: 100%; padding: 8px;
            background: #333; border: 1px solid #555;
            border-radius: 4px; color: var(--text-main);
            font-family: inherit;
        }
        textarea { min-height: 60px; resize: vertical; font-family: monospace; line-height: 1.4; }
        input[type="color"] { width: 100%; height: 35px; border: 1px solid #555; cursor: pointer; }

        /* --- OUTPUT ITEMS --- */
        .output-item {
            background: #2a2a2a; padding: 10px; margin-bottom: 10px;
            border-radius: 4px; border-left: 3px solid var(--accent);
        }
        .output-item.default { border-left-color: var(--success); }
        .output-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }

        /* --- OVERLAYS --- */
        #mode-indicator {
            position: absolute; top: 10px; left: 10px;
            background: rgba(30,30,30,0.9); padding: 6px 10px;
            border-radius: 4px; font-size: 12px; font-weight: bold; pointer-events: none;
        }
        .view-mode { color: var(--success); }
        .edit-mode { color: var(--warn); }

        .zoom-info {
            position: absolute; bottom: 10px; left: 10px;
            background: rgba(30,30,30,0.9); padding: 8px;
            border-radius: 4px; font-size: 12px; pointer-events: none;
        }

        #context-menu {
            position: fixed; background: #2a2a2a;
            border: 1px solid #555; border-radius: 4px;
            padding: 5px 0; z-index: 2000; display: none;
            min-width: 180px; box-shadow: 0 4px 12px rgba(0,0,0,0.5);
        }
        #context-menu.active { display: block; }
        .ctx-item { padding: 8px 15px; cursor: pointer; font-size: 13px; }
        .ctx-item:hover { background: #3a3a3a; }
    </style>
</head>
<body>

    <!-- MENUS -->
    <div id="menu-bar">
        <div class="menu-item" data-menu="file">File
            <div class="dropdown" id="fileDropdown">
                <!-- Basic Operations (Stubs) -->
                <div id="btn-new" class="dropdown-item">New</div>
                <div id="btn-open" class="dropdown-item">Open...</div>
                
                <div class="separator"></div>
                
                <div id="btn-save-stub" class="dropdown-item">Save <span class="shortcut">Ctrl+S</span></div>
                <div id="btn-save-as-stub" class="dropdown-item">Save As... <span class="shortcut">Shift+Ctrl+S</span></div>

                <div class="separator"></div>

                <!-- IMPORT Submenu -->
                <div class="dropdown-item">
                    Import
                    <span class="arrow">▶</span>
                    <div class="submenu">
                        <div id="btn-import-c3" class="dropdown-item">Import (*.json & *.uistate.json)</div>
                        <div id="btn-import-mini" class="dropdown-item">Import MiniFlow (*.miniflow.json)</div>
                    </div>
                </div>

                <!-- EXPORT Submenu -->
                <div class="dropdown-item">
                    Export
                    <span class="arrow">▶</span>
                    <div class="submenu">
                        <div id="btn-export-c3" class="dropdown-item">Export (*.json & *.uistate.json)</div>
                        <div id="btn-export-mini" class="dropdown-item">Export MiniFlow (*.miniflow.json)</div>
                    </div>
                </div>
            </div>
        </div>
        <div class="menu-item" id="menu-edit-wrapper" style="opacity: 0.5; pointer-events: none;">Edit
            <div class="dropdown" id="editDropdown">
                <div id="btn-toggle-mode" class="dropdown-item">Enter Edit Mode</div>
                <div id="btn-cancel-edit" class="dropdown-item" style="color: var(--danger); display: none;">Cancel Editing</div>
            </div>
        </div>
        <div class="menu-item" data-menu="view">View
            <div class="dropdown" id="viewDropdown">
                <div id="btn-reset-view" class="dropdown-item">Reset View</div>
            </div>
        </div>
        <div id="status-bar" style="margin-left: 20px; font-size: 11px; color: #aaa;">No flowchart loaded</div>
        <div id="filename-display" style="margin-left: auto; padding-right: 15px; color: var(--accent); font-size: 11px; font-weight: bold;"></div>
    </div>

    <!-- TOOLBAR -->
    <div id="toolbar">
        <div class="toolbar-group">
            <button class="btn small" id="tool-add-node">Add Node</button>
            <button class="btn small" id="tool-del-node" disabled>Delete Node</button>
        </div>
        <div class="toolbar-group">
            <button class="btn small" id="tool-add-out" disabled>Add Output</button>
            <button class="btn small" id="tool-del-out" disabled>Delete Output</button>
        </div>
        <div class="toolbar-group">
            <button class="btn small" id="tool-enable" disabled>Enable/Disable</button>
            <button class="btn small" id="tool-start" disabled>Set Start</button>
        </div>
    </div>

    <!-- WORKSPACE -->
    <div id="workspace">
        <div id="canvas-container">
            <canvas id="canvas"></canvas>
            <div id="mode-indicator" class="view-mode">VIEW MODE</div>
            <div class="zoom-info">
                <div>Zoom: <span id="zoom-level">100%</span></div>
                <div id="edit-hint" style="display:none; color: var(--warn); margin-top:4px;">Right-click for options</div>
            </div>
        </div>
        <div id="properties-panel">
            <div class="prop-group"><h3>No Selection</h3></div>
        </div>
    </div>

    <!-- HIDDEN & OVERLAYS -->
    <input type="file" id="file-input" accept=".json" multiple style="display: none;">
    <input type="file" id="file-input-mini" accept=".json" style="display: none;">
    <div id="context-menu"></div>

    <script>
        // --- CONFIGURATION ---
        const CONFIG = {
            colors: {
                header: '#246aa2',
                headerStart: '#4caf50',
                outputNameDefault: '#4f99d4', 
                borderDefault: '#000000',
                selection: '#0078d4',
                connection: '#666666',
                connectionHover: '#ff9800',
                connectionDefault: '#4caf50',
                bgNode: '#2b2b2b',
                grid: '#3a3a3a',
                text: '#ffffff',
                textDim: '#888888'
            },
            dims: {
                nodeW: 420,
                headerH: 32,      // Высота заголовка
                rowH: 33,         // Высота строки выхода (по замерам)
                footerH: 32,      // Высота подвала (для тегов)
                dotRadius: 8,
                borderRadius: 6,
                gridSize: 500,
                resizeMargin: 8
            },
            zoom: { min: 0.05, max: 2, stepIn: 1.1, stepOut: 0.9 },
            clickThreshold: 50
        };

        // --- MATH UTILS ---
        const Utils = {
            screenToWorld: (sx, sy, panX, panY, zoom) => ({ x: (sx - panX) / zoom, y: (sy - panY) / zoom }),
            worldToScreen: (wx, wy, panX, panY, zoom) => ({ x: wx * zoom + panX, y: wy * zoom + panY }),
            dist: (p1, p2) => Math.hypot(p1.x - p2.x, p1.y - p2.y),
            isPointInRect: (px, py, rx, ry, rw, rh) => px >= rx && px <= rx + rw && py >= ry && py <= ry + rh,
            isPointNearBezier: (px, py, p0, p3, threshold) => {
                const cpDist = Math.abs(p3.x - p0.x) * 0.5;
                const p1 = { x: p0.x + cpDist, y: p0.y };
                const p2 = { x: p3.x - cpDist, y: p3.y };
                const steps = 20;
                for (let i = 0; i <= steps; i++) {
                    const t = i / steps;
                    const it = 1 - t;
                    const x = it*it*it*p0.x + 3*it*it*t*p1.x + 3*it*t*t*p2.x + t*t*t*p3.x;
                    const y = it*it*it*p0.y + 3*it*it*t*p1.y + 3*it*t*t*p2.y + t*t*t*p3.y;
                    if (Math.hypot(px - x, py - y) < threshold) return true;
                }
                return false;
            },
            uuid: () => Date.now() + Math.floor(Math.random() * 1000000)
        };

        class FlowchartEditor {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                
                // Data
                this.data = { flowchart: null, ui: null, original: null };
                
                // Viewport State
                this.view = { zoom: 1, panX: 0, panY: 0 };
                
                // Interaction State
                this.state = {
                    mode: 'view', // 'view' or 'edit'
                    dragging: false,
                    lastMouse: { x: 0, y: 0 },
                    selection: { node: null, output: null },
                    dragNode: null,
                    connectionStart: null,
                    hover: { node: null, output: null, connection: null },

                    // Смещение для драга и флаги ресайза
                    dragOffset: null,
                    resizing: false,
                    resizeTarget: null,
                    resizeDir: null
                };
                // Буфер обмена
                this.clipboard = null; 

                this.init();
            }

            init() {
                this.resize();
                window.addEventListener('resize', () => { this.resize(); this.render(); });
                this.bindEvents();
            }

            resize() {
                const parent = this.canvas.parentElement;
                this.canvas.width = parent.clientWidth;
                this.canvas.height = parent.clientHeight;
            }

            bindEvents() {
                const c = this.canvas;
                c.addEventListener('mousedown', e => this.handleInput('down', e));
                c.addEventListener('mousemove', e => this.handleInput('move', e));
                c.addEventListener('mouseup', e => this.handleInput('up', e));
                c.addEventListener('mouseleave', () => { this.state.dragging = false; this.state.dragNode = null; });
                
                c.addEventListener('wheel', e => {
                    if (e.ctrlKey) {
                        e.preventDefault();
                        
                        const rect = c.getBoundingClientRect();
                        const mx = e.clientX - rect.left;
                        const my = e.clientY - rect.top;

                        // 1. Получаем координаты мира ПОД курсором ДО зума
                        const worldX = (mx - this.view.panX) / this.view.zoom;
                        const worldY = (my - this.view.panY) / this.view.zoom;

                        // 2. Вычисляем новый зум
                        const f = e.deltaY > 0 ? CONFIG.zoom.stepOut : CONFIG.zoom.stepIn;
                        const newZoom = Math.max(CONFIG.zoom.min, Math.min(CONFIG.zoom.max, this.view.zoom * f));

                        // 3. Вычисляем новый Pan так, чтобы точка мира осталась под курсором
                        // mx = worldX * newZoom + newPanX  =>  newPanX = mx - worldX * newZoom
                        this.view.panX = mx - worldX * newZoom;
                        this.view.panY = my - worldY * newZoom;
                        this.view.zoom = newZoom;

                        document.getElementById('zoom-level').textContent = Math.round(this.view.zoom * 100) + '%';
                        this.render();
                    }
                });

                c.addEventListener('contextmenu', e => {
                    e.preventDefault();
                    if (this.state.mode === 'edit') this.showContextMenu(e);
                });

                document.addEventListener('click', () => document.getElementById('context-menu').classList.remove('active'));
            }

            // --- INPUT HANDLING ---

            handleInput(type, e) {
                const rect = this.canvas.getBoundingClientRect();
                const mx = e.clientX - rect.left;
                const my = e.clientY - rect.top;

                // --- 1. MOUSE DOWN ---
                if (type === 'down') {
                    if (this.state.mode === 'edit') {
                        // Шаг 1: Приоритет на Output
                        const hitNode = this.hitTestNode(mx, my);
                        const hitOut = hitNode ? this.hitTestOutput(hitNode, mx, my) : null;

                        if (hitNode && hitOut) {
                            this.state.connectionStart = { node: hitNode, output: hitOut.output };
                            this.state.lastMouse = { x: e.clientX, y: e.clientY }; 
                            this.render();
                            return; 
                        }

                        // Шаг 2: Ресайз
                        const resizeHit = this.hitTestResize(mx, my);
                        if (resizeHit) {
                            this.state.resizing = true;
                            this.state.resizeTarget = resizeHit.node;
                            this.state.resizeDir = resizeHit.dir;
                            this.state.lastMouse = { x: e.clientX, y: e.clientY };
                            return; 
                        }

                        // Шаг 3: Перетаскивание Ноды / Выделение
                        if (hitNode) {
                            this.select(hitNode);
                            this.state.dragNode = hitNode;
                            
                            // --- ИСПРАВЛЕНИЕ ЗАХВАТА ---
                            // Вычисляем смещение между центром ноды и курсором в момент клика
                            const wp = Utils.screenToWorld(mx, my, this.view.panX, this.view.panY, this.view.zoom);
                            this.state.dragOffset = {
                                x: hitNode.x - wp.x,
                                y: hitNode.y - wp.y
                            };
                            
                        } else {
                            this.select(null);
                        }
                        this.render();
                    }
                    
                    // Pan
                    if (!this.state.dragNode && !this.state.connectionStart && !this.state.resizing) {
                        this.state.dragging = true;
                    }
                    this.state.lastMouse = { x: e.clientX, y: e.clientY };
                } 
                
                // --- 2. MOUSE MOVE ---
                else if (type === 'move') {
                    // А. Тянем РЕСАЙЗ
                    if (this.state.resizing && this.state.resizeTarget) {
                        const dx = (e.clientX - this.state.lastMouse.x) / this.view.zoom;
                        const dy = (e.clientY - this.state.lastMouse.y) / this.view.zoom;
                        const node = this.state.resizeTarget;
                        const minSize = this.getMinNodeSize(node);

                        if (this.state.resizeDir === 'w') {
                            const oldW = node.w;
                            const newW = Math.max(minSize.w, oldW + dx);
                            node.x += (newW - oldW) / 2;
                            node.w = newW;
                            this.canvas.style.cursor = 'ew-resize';
                        } else if (this.state.resizeDir === 'h') {
                            const oldH = node.h;
                            const newH = Math.max(minSize.h, oldH + dy);
                            node.y += (newH - oldH) / 2;
                            node.h = newH;
                            this.canvas.style.cursor = 'ns-resize';
                        }
                        this.state.lastMouse = { x: e.clientX, y: e.clientY };
                        this.render();
                        return;
                    }

                    // Б. Тянем СВЯЗЬ
                    if (this.state.connectionStart) {
                        const hitNode = this.hitTestNode(mx, my);
                        this.state.hover.node = (hitNode !== this.state.connectionStart.node) ? hitNode : null;
                        this.state.lastMouse = { x: e.clientX, y: e.clientY };
                        this.render();
                        return;
                    }

                    // В. Hover
                    if (this.state.mode === 'edit' && !this.state.dragging && !this.state.dragNode) {
                        const hitNode = this.hitTestNode(mx, my);
                        const hitOut = hitNode ? this.hitTestOutput(hitNode, mx, my) : null;
                        
                        this.state.hover.node = hitNode;
                        this.state.hover.output = hitOut;
                        this.state.hover.connection = (!hitNode) ? this.hitTestConnection(mx, my) : null;

                        if (hitOut) {
                            this.canvas.style.cursor = 'crosshair'; 
                        } 
                        else {
                            const resizeHit = this.hitTestResize(mx, my);
                            if (resizeHit) {
                                this.canvas.style.cursor = resizeHit.dir === 'w' ? 'ew-resize' : 'ns-resize';
                            } else {
                                this.canvas.style.cursor = hitNode ? 'grab' : 'default';
                            }
                        }
                    }

                    // Г. Pan
                    if (this.state.dragging) {
                        this.view.panX += e.clientX - this.state.lastMouse.x;
                        this.view.panY += e.clientY - this.state.lastMouse.y;
                        this.canvas.style.cursor = 'grabbing';
                    } 
                    
                    // Д. Drag Node (ИСПРАВЛЕНО)
                    else if (this.state.dragNode) {
                        const wp = Utils.screenToWorld(mx, my, this.view.panX, this.view.panY, this.view.zoom);
                        
                        // Прибавляем сохраненное смещение к текущей позиции мыши
                        let newX = wp.x + this.state.dragOffset.x;
                        let newY = wp.y + this.state.dragOffset.y;
                        
                        // Проверка границ (Center Origin):
                        // Левый край (x - w/2) не должен быть меньше 0
                        if (newX - (this.state.dragNode.w / 2) < 0) {
                            newX = this.state.dragNode.w / 2;
                        }
                        
                        // Верхний край (y - h/2) не должен быть меньше 0. 
                        // *Внимание: мы не знаем реальную calculatedHeight здесь без пересчета, 
                        // но для грубой проверки node.h подойдет, или просто 0 для центра*
                        if (newY < 0) newY = 0; // Разрешим центру быть 0, верх чуть уйдет, не страшно.

                        this.state.dragNode.x = newX;
                        this.state.dragNode.y = newY;
                        this.canvas.style.cursor = 'grabbing';
                    }

                    this.state.lastMouse = { x: e.clientX, y: e.clientY };
                    this.render();
                } 
                
                // --- 3. MOUSE UP ---
                else if (type === 'up') {
                    if (this.state.resizing) {
                        this.state.resizing = false;
                        this.state.resizeTarget = null;
                        this.state.resizeDir = null;
                        this.canvas.style.cursor = 'default';
                    }

                    if (this.state.connectionStart) {
                        let target = this.state.hover.node || this.findClosestNode(mx, my);
                        if (target && target !== this.state.connectionStart.node) {
                            this.connect(this.state.connectionStart.node, this.state.connectionStart.output, target);
                        }
                        this.state.connectionStart = null;
                        this.render();
                    }
                    
                    this.state.dragging = false;
                    this.state.dragNode = null;
                    this.state.dragOffset = null; // Очистка смещения
                }
            }

            // --- HIT TESTING ---

            hitTestNode(mx, my) {
                if (!this.data.flowchart) return null;
                const wp = Utils.screenToWorld(mx, my, this.view.panX, this.view.panY, this.view.zoom);
                
                for (let i = this.data.flowchart.nodes.length - 1; i >= 0; i--) {
                    const n = this.data.flowchart.nodes[i];
                    
                    const outputsCount = n.outputs ? n.outputs.length : 0;
                    const contentH = CONFIG.dims.headerH + (outputsCount * CONFIG.dims.rowH) + CONFIG.dims.footerH + 10;
                    const actualH = Math.max(n.h, contentH);

                    const left = n.x - (n.w / 2);
                    const top = n.y - (actualH / 2);
                    
                    if (Utils.isPointInRect(wp.x, wp.y, left, top, n.w, actualH)) return n;
                }
                return null;
            }

            // Проверка попадания в границы ноды для ресайза
            // Возвращает объект { node, dir: 'w' | 'h' } или null
            hitTestResize(mx, my) {
                if (!this.data.flowchart) return null;
                const margin = CONFIG.dims.resizeMargin;
                
                for (let i = this.data.flowchart.nodes.length - 1; i >= 0; i--) {
                    const n = this.data.flowchart.nodes[i];
                    
                    const outputsCount = n.outputs ? n.outputs.length : 0;
                    const contentH = CONFIG.dims.headerH + (outputsCount * CONFIG.dims.rowH) + CONFIG.dims.footerH + 10;
                    
                    // Используем реальную высоту (юзерскую или контентную)
                    const actualH = Math.max(n.h, contentH);
                    
                    const topLeftX = n.x - (n.w / 2);
                    const topLeftY = n.y - (actualH / 2);
                    
                    const screenPos = Utils.worldToScreen(topLeftX, topLeftY, this.view.panX, this.view.panY, this.view.zoom);
                    const screenW = n.w * this.view.zoom;
                    const screenH = actualH * this.view.zoom;

                    const left = screenPos.x;
                    const right = screenPos.x + screenW;
                    const top = screenPos.y;
                    const bottom = screenPos.y + screenH;

                    if (my >= top && my <= bottom && mx >= right - margin && mx <= right + margin) return { node: n, dir: 'w' };
                    if (mx >= left && mx <= right && my >= bottom - margin && my <= bottom + margin) return { node: n, dir: 'h' };
                }
                return null;
            }

            hitTestOutput(node, mx, my) {
                if (!node.outputs) return null;
                
                const outputsCount = node.outputs.length;
                const contentH = CONFIG.dims.headerH + (outputsCount * CONFIG.dims.rowH) + CONFIG.dims.footerH + 10;
                const actualH = Math.max(node.h, contentH);
                
                const topLeftX = node.x - (node.w / 2);
                const topLeftY = node.y - (actualH / 2);
                
                const sp = Utils.worldToScreen(topLeftX, topLeftY, this.view.panX, this.view.panY, this.view.zoom);
                
                const startY = sp.y + CONFIG.dims.headerH * this.view.zoom + (5 * this.view.zoom);
                const dotX = sp.x + node.w * this.view.zoom;
                const r = 20 * this.view.zoom; 

                for (let i = 0; i < node.outputs.length; i++) {
                    const dotY = startY + (i * CONFIG.dims.rowH * this.view.zoom) + (CONFIG.dims.rowH * this.view.zoom / 2);
                    if (Math.hypot(mx - dotX, my - dotY) < r) return { output: node.outputs[i], index: i };
                }
                return null;
            }

            hitTestConnection(mx, my) {
                if (!this.data.flowchart) return null;
                for (const node of this.data.flowchart.nodes) {
                    if (!node.outputs) continue;
                    for (let i = 0; i < node.outputs.length; i++) {
                        const out = node.outputs[i];
                        if (out.cnSID && out.enable) {
                            const target = this.data.flowchart.nodes.find(n => n.sid === out.cnSID);
                            if (target) {
                                const pStart = this.getOutputPos(node, i);
                                
                                // ИЗМЕНЕНИЕ: Используем правильную точку входа для проверки наведения
                                const pEnd = this.getNodeInputPos(target);
                                
                                if (Utils.isPointNearBezier(mx, my, pStart, pEnd, 5)) return { output: out };
                            }
                        }
                    }
                }
                return null;
            }

            findClosestNode(mx, my) {
                const wp = Utils.screenToWorld(mx, my, this.view.panX, this.view.panY, this.view.zoom);
                let closest = null, minDist = CONFIG.clickThreshold;
                this.data.flowchart.nodes.forEach(n => {
                    const d = Utils.dist(wp, { x: n.x + n.w/2, y: n.y + n.h/2 });
                    if (d < minDist) { minDist = d; closest = n; }
                });
                return closest;
            }

            getOutputPos(node, idx) {
                const hh = CONFIG.dims.headerH;
                const rh = CONFIG.dims.rowH;
                const fh = CONFIG.dims.footerH;
                const outputsCount = node.outputs ? node.outputs.length : 0;
                
                const contentH = hh + (outputsCount * rh) + fh + 10;
                const actualH = Math.max(node.h, contentH);
                
                const topLeftX = node.x - (node.w / 2);
                const topLeftY = node.y - (actualH / 2);

                const topPadding = 5; 
                const worldY = topLeftY + hh + topPadding + (idx * rh) + (rh / 2);
                const worldX = topLeftX + node.w;

                return Utils.worldToScreen(worldX, worldY, this.view.panX, this.view.panY, this.view.zoom);
            }

            getNodeInputPos(node) {
                // node.y - это уже центр по вертикали!
                const worldY = node.y;
                
                // Левая грань = центр - половина ширины
                const worldX = node.x - (node.w / 2);

                return Utils.worldToScreen(worldX, worldY, this.view.panX, this.view.panY, this.view.zoom);
            }

            // --- LOGIC & CRUD ---

            connect(source, output, target) {
                output.cnSID = target.sid;
                // Note: Full connectivity (pnSIDs etc) is rebuilt on save to ensure consistency
            }

            select(node) {
                this.state.selection.node = node;
                // Update UI
                const panel = document.getElementById('properties-panel');
                if (node) this.generateProperties(node);
                else panel.innerHTML = '<div class="prop-group"><h3>No Selection</h3></div>';
                
                // Update Toolbar
                document.getElementById('tool-del-node').disabled = !node;
                document.getElementById('tool-add-out').disabled = !node;
                document.getElementById('tool-del-out').disabled = true; 
                document.getElementById('tool-enable').disabled = !node;
                document.getElementById('tool-start').disabled = !node;
            }

            addNode(screenX, screenY) {
                const wp = Utils.screenToWorld(screenX, screenY, this.view.panX, this.view.panY, this.view.zoom);
                
                // Рассчитываем высоту для 1 выхода (дефолт)
                const defaultOutputsCount = 1;
                const calcH = CONFIG.dims.headerH + (defaultOutputsCount * CONFIG.dims.rowH) + CONFIG.dims.footerH + 10;

                const newNode = {
                    sid: Utils.uuid(), 
                    pnSIDs: [], poSIDs: [], nodeSIDs: [],
                    x: wp.x - 210, 
                    y: wp.y - (calcH / 2), 
                    w: 420, 
                    h: calcH, // <--- Правильная начальная высота
                    t: "", s: false, e: true, c: "New Node",
                    pi: 0, ty: "dictionary", pr: false, prfsid: null, prfnsid: null,
                    outputs: [{ 
                        sid: Utils.uuid()+1, 
                        cnSID: null, 
                        name: "Option 1", 
                        value: "", 
                        enable: true, 
                        default: false 
                    }]
                };
                
                this.data.flowchart.nodes.push(newNode);

                // 2. UI State Structure (matches backup)
                this.data.ui.nodes.push({ 
                    node: { 
                        propertiesBar: {}, 
                        nodeTable: {}, 
                        color: [0.8, 0.8, 0.8, 1] 
                    }, 
                    outputs: [{ 
                        color: [0, 0, 0, 1], 
                        linkMode: "line", 
                        propertiesBar: {} 
                    }] 
                });
                
                this.select(newNode);
                this.render();
            }

            deleteNode(node) {
                if (!node) return;
                const idx = this.data.flowchart.nodes.indexOf(node);
                if (idx > -1) {
                    // Cleanup connections
                    this.data.flowchart.nodes.forEach(n => {
                        n.outputs?.forEach(o => { if (o.cnSID === node.sid) o.cnSID = null; });
                        // We will rebuild pnSIDs on save, but removing dangling IDs here helps
                        n.pnSIDs = n.pnSIDs?.filter(id => id !== node.sid);
                        n.nodeSIDs = n.nodeSIDs?.filter(id => id !== node.sid);
                    });
                    
                    // Remove from both logic and UI arrays at the same index
                    this.data.flowchart.nodes.splice(idx, 1);
                    this.data.ui.nodes.splice(idx, 1);
                    
                    this.select(null);
                    this.render();
                }
            }

            getMinNodeSize(node) {
                // Минимальная ширина (заголовок должен влезать хотя бы частично)
                const minW = 200; 

                // Минимальная высота: Шапка + Выходы + Футер + Отступы
                const hh = CONFIG.dims.headerH;
                const rh = CONFIG.dims.rowH;
                const fh = CONFIG.dims.footerH;
                const outputsCount = node.outputs ? node.outputs.length : 0;
                
                // 10px padding
                const minH = hh + (outputsCount * rh) + fh + 10;

                return { w: minW, h: minH };
            }

            // --- CLIPBOARD OPERATIONS ---

            copyNode(node) {
                if (!node) return;
                
                // Находим индекс, чтобы скопировать также UI-данные (цвет)
                const idx = this.data.flowchart.nodes.indexOf(node);
                const uiNode = this.data.ui.nodes[idx];

                // Глубокое копирование через JSON, чтобы разорвать ссылки
                this.clipboard = {
                    logic: JSON.parse(JSON.stringify(node)),
                    ui: JSON.parse(JSON.stringify(uiNode))
                };
                
                // console.log("Node copied to internal clipboard");
            }

            pasteNode(screenX, screenY) {
                if (!this.clipboard) return;

                const wp = Utils.screenToWorld(screenX, screenY, this.view.panX, this.view.panY, this.view.zoom);
                
                // 1. Подготовка логической ноды
                const newNode = JSON.parse(JSON.stringify(this.clipboard.logic));
                
                // Генерируем новый SID ноды
                newNode.sid = Utils.uuid();
                
                // Устанавливаем позицию (центр ноды под курсором)
                newNode.x = wp.x;
                newNode.y = wp.y;
                
                // Очищаем связи
                newNode.pnSIDs = [];
                newNode.poSIDs = [];
                newNode.nodeSIDs = [];
                
                // Генерируем новые ID для выходов и сбрасываем их связи
                if (newNode.outputs) {
                    newNode.outputs.forEach(out => {
                        out.sid = Utils.uuid(); // Новый ID выхода
                        out.cnSID = null;       // Разрыв исходящей связи
                    });
                }

                // 2. Подготовка UI данных
                const newUiNode = JSON.parse(JSON.stringify(this.clipboard.ui));
                
                // Добавляем в модель
                this.data.flowchart.nodes.push(newNode);
                this.data.ui.nodes.push(newUiNode);

                // Выделяем вставленную ноду
                this.select(newNode);
                this.render();
            }

            // --- RENDERING ---

            render() {
                if (!this.data.flowchart) return;
                const ctx = this.ctx;
                ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                // 1. СЕТКА И ОСИ
                this.drawGrid();
                
                // 2. СВЯЗИ
                this.data.flowchart.nodes.forEach((node, nIdx) => {
                    node.outputs?.forEach((out, oIdx) => {
                        if (out.cnSID && out.enable) {
                            const target = this.data.flowchart.nodes.find(n => n.sid === out.cnSID);
                            if (target) this.drawConnection(node, nIdx, out, oIdx, target);
                        }
                    });
                });

                // 2.1 Активная связь (drag)
                 if (this.state.connectionStart) {
                    const start = this.getOutputPos(this.state.connectionStart.node, 
                        this.state.connectionStart.node.outputs.indexOf(this.state.connectionStart.output));
                    
                    // Координаты мыши
                    const rect = this.canvas.getBoundingClientRect();
                    let end = { 
                        x: this.state.lastMouse.x - rect.left, 
                        y: this.state.lastMouse.y - rect.top 
                    };
                    
                    if (this.state.hover.node) {
                        // ИЗМЕНЕНИЕ: Магнитизм к правильному центру визуальной ноды
                        end = this.getNodeInputPos(this.state.hover.node);
                    }

                    ctx.beginPath();
                    ctx.strokeStyle = '#fff';
                    ctx.setLineDash([5, 5]);
                    ctx.moveTo(start.x, start.y);
                    ctx.lineTo(end.x, end.y);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }

                // 3. НОДЫ
                this.data.flowchart.nodes.forEach((node, i) => this.drawNode(node, i));
            }

            drawGrid() {
                const ctx = this.ctx;
                const zoom = this.view.zoom;
                const panX = this.view.panX;
                const panY = this.view.panY;
                const cellSize = CONFIG.dims.gridSize * zoom;
                
                const w = this.canvas.width;
                const h = this.canvas.height;

                ctx.save();
                ctx.beginPath();
                ctx.strokeStyle = CONFIG.colors.grid;
                ctx.lineWidth = 1;

                // Вычисляем смещение сетки, чтобы она двигалась вместе с панорамой
                // startX/Y - это позиция первой линии на экране
                const startX = panX % cellSize;
                const startY = panY % cellSize;

                // Вертикальные линии
                for (let x = startX; x < w; x += cellSize) {
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, h);
                }

                // Горизонтальные линии
                for (let y = startY; y < h; y += cellSize) {
                    ctx.moveTo(0, y);
                    ctx.lineTo(w, y);
                }
                ctx.stroke();

                // ОСИ НАЧАЛА КООРДИНАТ (0,0)
                // Рисуем их только если они находятся в видимой области
                // Они должны быть поверх обычной сетки и пунктирными
                ctx.beginPath();
                ctx.strokeStyle = '#666';
                ctx.lineWidth = 2;
                ctx.setLineDash([10, 10]);

                if (panX >= -50 && panX <= w + 50) {
                    ctx.moveTo(panX, 0);
                    ctx.lineTo(panX, h);
                }
                if (panY >= -50 && panY <= h + 50) {
                    ctx.moveTo(0, panY);
                    ctx.lineTo(w, panY);
                }
                ctx.stroke();

                // Текст (0,0)
                if (panX > -100 && panX < w && panY > -100 && panY < h) {
                    ctx.fillStyle = '#888';
                    ctx.font = '12px monospace';
                    ctx.setLineDash([]);
                    ctx.fillText("(0, 0)", panX + 5, panY + 15);
                }

                ctx.restore();
            }

             drawConnection(n1, n1Idx, output, oIdx, n2) {
                const start = this.getOutputPos(n1, oIdx);
                
                // Используем вычисляемый центр визуальной высоты целевой ноды
                const end = this.getNodeInputPos(n2);
                
                let color = CONFIG.colors.connection;
                let width = 2;
                
                if (this.state.hover.connection && this.state.hover.connection.output === output) {
                    color = CONFIG.colors.connectionHover; width = 4;
                } else if (output.default) {
                    color = CONFIG.colors.connectionDefault; width = 3;
                }

                const cpOffset = Math.abs(end.x - start.x) * 0.5;
                this.ctx.beginPath();
                this.ctx.strokeStyle = color;
                this.ctx.lineWidth = width;
                this.ctx.moveTo(start.x, start.y);
                this.ctx.bezierCurveTo(start.x + cpOffset, start.y, end.x - cpOffset, end.y, end.x, end.y);
                this.ctx.stroke();

                // Arrow
                this.ctx.beginPath();
                this.ctx.arc(end.x, end.y, 4, 0, Math.PI*2);
                this.ctx.fillStyle = color;
                this.ctx.fill();
            }

            drawNode(node, idx) {
                const zoom = this.view.zoom;
                const w = node.w * zoom;
                
                const hh = CONFIG.dims.headerH * zoom; 
                const rh = CONFIG.dims.rowH * zoom;    
                const fh = CONFIG.dims.footerH * zoom; 
                const outputsCount = node.outputs ? node.outputs.length : 0;
                
                // Минимально необходимая высота для контента
                const contentHeightRaw = CONFIG.dims.headerH + (outputsCount * CONFIG.dims.rowH) + CONFIG.dims.footerH + 10;
                
                // Итоговая высота ноды: либо то, что задал юзер (node.h), либо контент, если юзер задал меньше
                const actualH = Math.max(node.h, contentHeightRaw);
                const h = actualH * zoom;

                // Смещение координат (Center Origin)
                // Рисуем от: ЦентрX - Ширина/2, ЦентрY - Высота/2
                const drawX = node.x - (node.w / 2);
                const drawY = node.y - (actualH / 2);

                const pos = Utils.worldToScreen(drawX, drawY, this.view.panX, this.view.panY, zoom);
                const rad = CONFIG.dims.borderRadius * zoom;

                // ... (Далее код отрисовки цветов и фона без изменений) ...
                let borderColor = CONFIG.colors.borderDefault;
                if (this.data.ui.nodes[idx]?.node?.color) {
                    const c = this.data.ui.nodes[idx].node.color;
                    borderColor = `rgb(${c[0]*255}, ${c[1]*255}, ${c[2]*255})`;
                }
                const headerBgColor = node.s ? CONFIG.colors.headerStart : CONFIG.colors.header;
                const outputNameColor = node.s ? CONFIG.colors.headerStart : CONFIG.colors.outputNameDefault;

                this.ctx.save();
                this.ctx.beginPath();
                this.ctx.roundRect(pos.x, pos.y, w, h, rad);
                this.ctx.fillStyle = CONFIG.colors.bgNode;
                this.ctx.fill();

                this.ctx.save();
                this.ctx.clip(); 
                this.ctx.fillStyle = headerBgColor;
                this.ctx.fillRect(pos.x, pos.y, w, hh);
                this.ctx.restore();

                this.ctx.lineWidth = (node === this.state.selection.node) ? 3 : 1;
                this.ctx.strokeStyle = (node === this.state.selection.node) ? CONFIG.colors.selection : borderColor;
                if (this.state.hover.node === node && this.state.connectionStart) this.ctx.strokeStyle = CONFIG.colors.connectionHover;
                this.ctx.stroke();

                this.ctx.textAlign = 'left'; 
                this.ctx.fillStyle = CONFIG.colors.text;
                this.ctx.font = `bold ${Math.max(10, 13 * zoom)}px sans-serif`;
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText(node.c || 'Node', pos.x + 10*zoom, pos.y + hh/2, w - 20);

                // INPUT DOT (строго по центру ИТОГОВОЙ высоты)
                this.ctx.beginPath();
                this.ctx.arc(pos.x, pos.y + h/2, 5*zoom, -Math.PI/2, Math.PI/2);
                this.ctx.fillStyle = '#555';
                this.ctx.fill();

                if (node.outputs) {
                    const startY = hh + (5 * zoom); 
                    node.outputs.forEach((out, i) => this.drawOutput(node, out, i, pos, startY, outputNameColor));
                }

                if (node.t) {
                    this.ctx.textAlign = 'left';
                    this.ctx.fillStyle = CONFIG.colors.textDim;
                    this.ctx.font = `italic ${Math.max(9, 11 * zoom)}px sans-serif`;
                    // Тэги всегда в самом низу текущей высоты
                    this.ctx.fillText(node.t, pos.x + 10*zoom, pos.y + h - (fh/2) + 2);
                }

                if (!node.e) {
                    this.ctx.fillStyle = 'rgba(0,0,0,0.5)';
                    this.ctx.fill();
                }
                this.ctx.restore();
            }

            drawOutput(node, out, idx, pos, startY, nameColor) {
                const rh = CONFIG.dims.rowH * this.view.zoom;
                const yOff = startY + (idx * rh);
                const textY = pos.y + yOff + rh/2;

                // Текст справа
                this.ctx.textAlign = 'right';
                
                let currentX = pos.x + (node.w * this.view.zoom) - (15 * this.view.zoom);
                const fontBaseSize = Math.max(9, 12 * this.view.zoom);
                
                // (Default)
                if (out.default) {
                    this.ctx.font = `bold ${Math.max(8, 10 * this.view.zoom)}px sans-serif`;
                    this.ctx.fillStyle = '#4caf50';
                    const defText = ' (Default)';
                    this.ctx.fillText(defText, currentX, textY);
                    currentX -= this.ctx.measureText(defText).width;
                }

                // Value
                if (out.value) {
                    this.ctx.font = `${fontBaseSize}px sans-serif`;
                    this.ctx.fillStyle = '#ccc';
                    const valText = `: ${out.value}`;
                    this.ctx.fillText(valText, currentX, textY);
                    currentX -= this.ctx.measureText(valText).width;
                }

                // Name
                this.ctx.font = `bold ${fontBaseSize}px sans-serif`;
                this.ctx.fillStyle = nameColor; 
                this.ctx.fillText(out.name, currentX, textY);

                // Точка коннектора
                const cx = pos.x + node.w * this.view.zoom;
                const cy = pos.y + yOff + rh/2;
                
                this.ctx.beginPath();
                this.ctx.arc(cx, cy, CONFIG.dims.dotRadius * this.view.zoom, 0, Math.PI*2);
                this.ctx.fillStyle = (this.state.hover.output?.output === out) ? '#fff' : (out.cnSID ? CONFIG.colors.selection : '#444');
                this.ctx.fill();
                this.ctx.stroke();
                
                this.ctx.textAlign = 'left'; 
            }

            // --- UI GENERATION ---

            generateProperties(node) {
                const p = document.getElementById('properties-panel');
                const val = (v) => (v || '').replace(/"/g, '&quot;');
                
                let html = `
                    <div class="prop-group">
                        <h3>Node Properties</h3>
                        <div class="prop-row"><label>Caption</label><input type="text" class="node-input" data-key="c" value="${val(node.c)}"></div>
                        <div class="prop-row"><label>Tags</label><input type="text" class="node-input" data-key="t" value="${val(node.t)}"></div>
                        <div class="prop-row"><label><input type="checkbox" class="node-check" data-key="e" ${node.e?'checked':''}> Enabled</label></div>
                        <div class="prop-row"><label><input type="checkbox" class="node-check" data-key="s" ${node.s?'checked':''}> Start Node</label></div>
                    </div>
                    <div class="prop-group">
                        <h3>Outputs <button class="btn small" style="float:right" id="prop-add-out">Add</button></h3>
                        <div id="out-list">
                `;

                node.outputs.forEach((o, i) => {
                    html += `
                        <div class="output-item ${o.default?'default':''}">
                            <div class="output-header"><strong>#${i+1}</strong> <button class="btn small danger" data-del-out="${i}">X</button></div>
                            <div class="prop-row"><label>Name</label><input type="text" class="out-input" data-idx="${i}" data-key="name" value="${val(o.name)}"></div>
                            <div class="prop-row"><label>Value</label><textarea class="out-input" data-idx="${i}" data-key="value">${(o.value||'').replace(/\\n/g, '\n')}</textarea></div>
                            <div class="prop-row"><label><input type="checkbox" class="out-check" data-idx="${i}" data-key="enable" ${o.enable?'checked':''}> Enabled</label></div>
                            <div class="prop-row"><label><input type="checkbox" class="out-check" data-idx="${i}" data-key="default" ${o.default?'checked':''}> Default</label></div>
                        </div>
                    `;
                });
                html += '</div></div>';
                p.innerHTML = html;

                // Event Listeners
                p.querySelectorAll('.node-input').forEach(el => el.oninput = e => { node[e.target.dataset.key] = e.target.value; this.render(); });
                p.querySelectorAll('.node-check').forEach(el => el.onchange = e => { 
                    if(e.target.dataset.key === 's' && e.target.checked) this.data.flowchart.nodes.forEach(n=>n.s=false);
                    node[e.target.dataset.key] = e.target.checked; 
                    this.render(); 
                });
                
                p.querySelectorAll('.out-input').forEach(el => el.oninput = e => {
                    let v = e.target.value;
                    if(e.target.tagName === 'TEXTAREA') v = v.replace(/\n/g, '\\n');
                    node.outputs[e.target.dataset.idx][e.target.dataset.key] = v;
                    this.render();
                });
                p.querySelectorAll('.out-check').forEach(el => el.onchange = e => {
                    const idx = e.target.dataset.idx;
                    const key = e.target.dataset.key;
                    if (key === 'default' && e.target.checked) node.outputs.forEach(o => o.default = false);
                    node.outputs[idx][key] = e.target.checked;
                    this.generateProperties(node);
                    this.render();
                });
                
                // --- FIXED: SYNC LOGIC FOR ADD/DELETE OUTPUT ---
                const nodeIdx = this.data.flowchart.nodes.indexOf(node);

                // Внутри generateProperties
                document.getElementById('prop-add-out').onclick = () => {
                    node.outputs.push({ sid: Utils.uuid(), name: "Option", value:"", enable:true, default:false });
                    
                    // Увеличиваем высоту ноды на высоту строки (30px)
                    node.h += CONFIG.dims.rowH; 
                    
                    if (this.data.ui.nodes[nodeIdx]) {
                        this.data.ui.nodes[nodeIdx].outputs.push({ 
                            color: [0,0,0,1], 
                            linkMode: "line", 
                            propertiesBar: {} 
                        });
                    }
                    this.generateProperties(node); this.render();
                };

                p.querySelectorAll('[data-del-out]').forEach(b => b.onclick = e => {
                    const outIdx = parseInt(e.target.dataset.delOut);
                    node.outputs.splice(outIdx, 1);
                    
                    // Уменьшаем высоту, но проверяем минимум
                    const minSize = this.getMinNodeSize(node);
                    node.h = Math.max(minSize.h, node.h - CONFIG.dims.rowH);

                    if (this.data.ui.nodes[nodeIdx] && this.data.ui.nodes[nodeIdx].outputs) {
                        this.data.ui.nodes[nodeIdx].outputs.splice(outIdx, 1);
                    }
                    this.generateProperties(node); this.render();
                });
            }

            showContextMenu(e) {
                const menu = document.getElementById('context-menu');
                const items = [];
                const rect = this.canvas.getBoundingClientRect();
                
                // Проверяем, куда кликнули
                const mx = e.clientX - rect.left;
                const my = e.clientY - rect.top;

                // Для Paste нам нужны экранные координаты мыши, сохраняем их в замыкании
                const pasteX = mx;
                const pasteY = my;

                if (this.state.hover.connection) {
                    items.push({ txt: 'Delete Connection', fn: () => { this.state.hover.connection.output.cnSID = null; this.render(); }});
                } else if (this.state.hover.node) {
                    const n = this.state.hover.node;
                    // Действия с нодой
                    items.push({ txt: 'Copy Node', fn: () => this.copyNode(n) }); // <--- COPY
                    items.push({ txt: 'Delete Node', fn: () => this.deleteNode(n) });
                    items.push({ txt: '----------------', fn: () => {} }); // Separator simulation
                    items.push({ txt: n.e ? 'Disable' : 'Enable', fn: () => { n.e = !n.e; this.render(); }});
                    items.push({ txt: 'Set Start', fn: () => { this.data.flowchart.nodes.forEach(x=>x.s=false); n.s=true; this.render(); }});
                } else {
                    // Действия с холстом
                    items.push({ txt: 'Add Node', fn: () => this.addNode(e.clientX, e.clientY) });
                    
                    // <--- PASTE (Только если буфер не пуст)
                    if (this.clipboard) {
                        items.push({ txt: 'Paste Node', fn: () => this.pasteNode(pasteX, pasteY) });
                    }
                }

                menu.innerHTML = items.map((i, idx) => {
                    // Простая эмуляция разделителя
                    if (i.txt.startsWith('---')) return `<div style="border-top:1px solid #444; margin:4px 0;"></div>`;
                    return `<div class="ctx-item" data-i="${idx}">${i.txt}</div>`;
                }).join('');
                
                menu.style.left = e.clientX + 'px';
                menu.style.top = e.clientY + 'px';
                menu.classList.add('active');
                
                menu.onclick = (evt) => {
                    const idx = evt.target.dataset.i;
                    if(idx !== undefined) { items[idx].fn(); menu.classList.remove('active'); }
                };
            }

            // --- FILE OPERATIONS ---

            setMode(mode) {
                this.state.mode = mode;
                const ind = document.getElementById('mode-indicator');
                const tb = document.getElementById('toolbar');
                const c = this.canvas;
                
                if (mode === 'edit') {
                    this.data.original = JSON.parse(JSON.stringify(this.data.flowchart)); // Backup
                    ind.textContent = "EDIT MODE"; ind.className = "edit-mode";
                    tb.classList.add('active');
                    c.classList.add('editing');
                    document.getElementById('properties-panel').classList.add('active');
                    document.getElementById('menu-edit-wrapper').style.opacity = "1"; 
                    document.getElementById('btn-toggle-mode').textContent = "Save & Exit";
                    document.getElementById('btn-cancel-edit').style.display = "block";
                    document.getElementById('btn-save').classList.remove('disabled');
                    document.getElementById('edit-hint').style.display = 'block';
                } else {
                    ind.textContent = "VIEW MODE"; ind.className = "view-mode";
                    tb.classList.remove('active');
                    c.classList.remove('editing');
                    document.getElementById('properties-panel').classList.remove('active');
                    document.getElementById('btn-toggle-mode').textContent = "Enter Edit Mode";
                    document.getElementById('btn-cancel-edit').style.display = "none";
                    document.getElementById('btn-save').classList.add('disabled');
                    document.getElementById('edit-hint').style.display = 'none';
                    this.select(null);
                }
            }

            rebuildConnectivity() {
                // Ensure Arrays exist and are clean
                this.data.flowchart.nodes.forEach(n => {
                    n.pnSIDs = []; n.poSIDs = []; n.nodeSIDs = [];
                    n.x = Math.round(n.x); n.y = Math.round(n.y);
                });

                this.data.flowchart.nodes.forEach(src => {
                    src.outputs?.forEach(out => {
                        if (out.cnSID) {
                            const target = this.data.flowchart.nodes.find(n => n.sid === out.cnSID);
                            if (target) {
                                // Logic: Parent adds child ID
                                if(!src.nodeSIDs.includes(target.sid)) src.nodeSIDs.push(target.sid);
                                
                                // Logic: Child adds Parent ID AND Output ID (parallel arrays)
                                target.pnSIDs.push(src.sid);
                                target.poSIDs.push(out.sid);
                            } else {
                                out.cnSID = null; // Clean dead link
                            }
                        }
                    });
                });
            }

            load(json, ui) {
                this.data.flowchart = json;
                this.data.ui = ui;
                this.view.zoom = ui.flowchart?.z || 1;
                document.getElementById('zoom-level').textContent = Math.round(this.view.zoom * 100) + '%';
                
                // Center View
                let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
                json.nodes.forEach(n => { minX=Math.min(minX, n.x); minY=Math.min(minY, n.y); maxX=Math.max(maxX, n.x+n.w); maxY=Math.max(maxY, n.y+n.h); });
                if (minX !== Infinity) {
                    this.view.panX = this.canvas.width/2 - ((minX+maxX)/2)*this.view.zoom;
                    this.view.panY = this.canvas.height/2 - ((minY+maxY)/2)*this.view.zoom;
                }
                
                document.getElementById('menu-edit-wrapper').style.opacity = "1";
                document.getElementById('menu-edit-wrapper').style.pointerEvents = "auto";
                this.render();
            }

            // --- MINIFLOW IO ---

            /**
             * Конвертирует текущий граф в формат MiniFlow и скачивает файл.
             */
            exportMiniFlow() {
                // 1. Индексация и поиск корня
                let rootSid = null;
                
                // Ищем стартовую ноду (s=true)
                const startNode = this.data.flowchart.nodes.find(n => n.s);
                if (startNode) {
                    rootSid = startNode.sid;
                } else if (this.data.flowchart.nodes.length > 0) {
                    // Если стартовой нет, берем первую
                    rootSid = this.data.flowchart.nodes[0].sid;
                } else {
                    alert("Граф пуст");
                    return;
                }

                // 2. Генерация читаемых ID (Humanizing IDs)
                const idMap = new Map(); // SID -> StringID
                const usedIds = new Set();

                const generateId = (node) => {
                    // Приоритет: Tag -> Caption -> "node"
                    let base = (node.t || node.c || "node").trim();
                    // Санитизация: только англ буквы, цифры и _, lowercase
                    base = base.toLowerCase().replace(/[^a-z0-9]+/g, '_').replace(/^_+|_+$/g, '');
                    if (!base) base = "node";

                    let candidate = base;
                    let counter = 2;
                    while (usedIds.has(candidate)) {
                        candidate = `${base}_${counter}`;
                        counter++;
                    }
                    usedIds.add(candidate);
                    return candidate;
                };

                this.data.flowchart.nodes.forEach(node => {
                    idMap.set(node.sid, generateId(node));
                });

                // 3. Сборка структуры MiniFlow
                const miniFlow = {
                    root: idMap.get(rootSid),
                    nodes: {}
                };

                this.data.flowchart.nodes.forEach(node => {
                    const strId = idMap.get(node.sid);
                    
                    // Формируем выходы
                    const outputs = (node.outputs || []).map(out => {
                        let nextId = null;
                        if (out.cnSID && idMap.has(out.cnSID)) {
                            nextId = idMap.get(out.cnSID);
                        }
                        return {
                            name: out.name || "Next", // Обязательное поле
                            value: out.value || "",
                            next: nextId
                        };
                    });

                    // Валидация: если выходов нет, добавляем технический заглушку (по ТЗ)
                    if (outputs.length === 0) {
                        outputs.push({ name: "End", value: "", next: null });
                    }

                    miniFlow.nodes[strId] = {
                        caption: node.c || "",
                        tag: node.t || "",
                        outputs: outputs
                    };
                });

                // Скачивание
                const blob = new Blob([JSON.stringify(miniFlow, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = (this.data.flowchart.name || 'miniflow') + '.miniflow.json';
                a.click();
            }

            /**
             * Импортирует JSON в формате MiniFlow, конвертирует в C3 и загружает.
             */
            importMiniFlow(miniJson) {
                if (!miniJson.root || !miniJson.nodes) {
                    alert("Invalid MiniFlow format");
                    return;
                }

                // Шаг 1: Инициализация и Маппинг ID
                const c3Data = {
                    sid: Utils.uuid(),
                    nodes: [],
                    "preset-nodes": { items: [], subfolders: [] },
                    name: "Imported_MiniFlow",
                    w: 30000, h: 30000
                };
                
                // Для UI State создадим дефолтную структуру
                const uiData = { flowchart: { z: 1, sx: 0, sy: 0 }, nodes: [] };

                const sidMap = new Map(); // StringID -> C3 SID
                const nodesByStringId = miniJson.nodes;
                
                // Создаем SID для всех нод заранее
                Object.keys(nodesByStringId).forEach(strId => {
                    sidMap.set(strId, Utils.uuid());
                });

                if (!sidMap.has(miniJson.root)) {
                    alert("Root node not found in nodes list");
                    return;
                }

                // Шаг 2: Генерация нод (Первый проход - создание объектов)
                Object.entries(nodesByStringId).forEach(([strId, miniNode]) => {
                    const c3Sid = sidMap.get(strId);
                    
                    const outputsCount = Array.isArray(miniNode.outputs) ? miniNode.outputs.length : 0;
                    
                    // РАСЧЕТ ВЫСОТЫ ПО СТАНДАРТУ CONSTRUCT 3
                    // Шапка + (строки * 33) + Подвал + небольшой отступ
                    const calcH = CONFIG.dims.headerH + (outputsCount * CONFIG.dims.rowH) + CONFIG.dims.footerH + 10;

                    const c3Node = {
                        sid: c3Sid,
                        pnSIDs: [], poSIDs: [], nodeSIDs: [],
                        x: 0, y: 0, 
                        w: 420,       // Стандартная ширина
                        h: calcH,     // <--- Применяем рассчитанную высоту
                        t: miniNode.tag || "",
                        c: miniNode.caption || strId,
                        s: (strId === miniJson.root),
                        e: true,
                        ty: "dictionary", pi: 0, pr: false, prfsid: null, prfnsid: null,
                        outputs: []
                    };

                    // Создаем выходы (пока без связей)
                    if (Array.isArray(miniNode.outputs)) {
                        c3Node.outputs = miniNode.outputs.map(miniOut => ({
                            sid: Utils.uuid(), // Генерируем ID выхода
                            cnSID: null,       // Заполним на Шаге 3
                            name: miniOut.name || "Next",
                            value: miniOut.value || "",
                            enable: true,
                            default: false,
                            // Временное хранение цели для шага 3
                            _tempNext: miniOut.next 
                        }));
                        // Высота ноды зависит от кол-ва выходов
                        c3Node.h = 100 + (c3Node.outputs.length * 30);
                    }

                    c3Data.nodes.push(c3Node);
                    
                    // Добавляем UI state для ноды
                    uiData.nodes.push({
                        node: { color: [0.8, 0.8, 0.8, 1], propertiesBar: {}, nodeTable: {} },
                        outputs: c3Node.outputs.map(() => ({ color: [0,0,0,1], linkMode: "line", propertiesBar: {} }))
                    });
                });

                // Шаг 3: Линковка (Второй проход - Topology Resolution)
                c3Data.nodes.forEach(sourceNode => {
                    sourceNode.outputs.forEach(output => {
                        const targetStrId = output._tempNext;
                        delete output._tempNext; // Удаляем временное поле

                        if (targetStrId && sidMap.has(targetStrId)) {
                            const targetSid = sidMap.get(targetStrId);
                            const targetNode = c3Data.nodes.find(n => n.sid === targetSid);

                            if (targetNode) {
                                // Прямая связь
                                output.cnSID = targetSid;
                                
                                // Обратные ссылки (Critical for C3)
                                if (!sourceNode.nodeSIDs.includes(targetSid)) {
                                    sourceNode.nodeSIDs.push(targetSid);
                                }
                                targetNode.pnSIDs.push(sourceNode.sid);
                                targetNode.poSIDs.push(output.sid);
                            }
                        }
                    });
                });

                // Шаг 4: Авто-лейаут
                this._miniFlowAutoLayout(c3Data.nodes, sidMap.get(miniJson.root));

                // Загрузка в редактор
                this.load(c3Data, uiData);
                document.getElementById('filename-display').textContent = "Imported MiniFlow";
                document.getElementById('status-bar').textContent = `Imported ${c3Data.nodes.length} nodes from MiniFlow`;
            }

            /**
             * Простой алгоритм BFS для расстановки нод слоями.
             */
            _miniFlowAutoLayout(nodes, rootSid) {
                // КОНСТАНТЫ ОТСТУПОВ (Сдвигаем вправо и вниз от 0,0)
                const START_X = 300; 
                const START_Y = 300;
                
                const X_STEP = 500;
                const Y_STEP = 300;
                
                const visited = new Set();
                const queue = [{ sid: rootSid, layer: 0 }];
                
                // Отслеживаем следующий свободный Y для каждого слоя (X)
                const layerNextY = {}; 

                // Предварительно сбрасываем координаты
                nodes.forEach(n => { n.x = 0; n.y = 0; });

                while (queue.length > 0) {
                    const { sid, layer } = queue.shift();
                    
                    if (visited.has(sid)) continue;
                    visited.add(sid);

                    const node = nodes.find(n => n.sid === sid);
                    if (!node) continue;

                    // Расчет координат
                    if (layerNextY[layer] === undefined) layerNextY[layer] = 0;
                    
                    // X: Отступ + Слой * Шаг
                    node.x = START_X + (layer * X_STEP);
                    
                    // Y: Отступ + Накопленная высота в слое
                    node.y = START_Y + layerNextY[layer];
                    
                    // Сдвигаем Y для следующей ноды в этом слое
                    layerNextY[layer] += Math.max(node.h, 200) + 50; // Высота ноды + отступ

                    // Добавляем детей в очередь
                    if (node.outputs) {
                        node.outputs.forEach(out => {
                            if (out.cnSID && !visited.has(out.cnSID)) {
                                queue.push({ sid: out.cnSID, layer: layer + 1 });
                            }
                        });
                    }
                }

                // Центрируем камеру редактора на начало графа (с учетом отступа)
                this.view.panX = 50 - (START_X * this.view.zoom); 
                this.view.panY = 50 - (START_Y * this.view.zoom);
                
                // Если зум 1, то просто сбросим в удобную позицию
                if(this.view.zoom === 1) {
                    this.view.panX = 50;
                    this.view.panY = 50;
                }
            }
        }

        // --- APP INITIALIZATION ---

        const app = new FlowchartEditor('canvas');
        
        // 1. Dropdown Menu Logic
        document.querySelectorAll('.menu-item').forEach(m => {
            m.addEventListener('click', e => {
                const drop = m.querySelector('.dropdown');
                if(drop) {
                    const wasActive = drop.style.display === 'block';
                    document.querySelectorAll('.dropdown').forEach(d => d.style.display = 'none');
                    if(!wasActive) drop.style.display = 'block';
                    e.stopPropagation();
                }
            });
        });
        document.addEventListener('click', () => document.querySelectorAll('.dropdown').forEach(d => d.style.display = 'none'));

        // 2. C3 Import Logic (Native & UIState)
        const fileInputC3 = document.getElementById('file-input');
        
        fileInputC3.onchange = async (e) => {
            const files = Array.from(e.target.files);
            // Ищем пару файлов .json и .uistate.json
            const jFile = files.find(f => f.name.endsWith('.json') && !f.name.endsWith('.uistate.json'));
            const uFile = files.find(f => f.name.endsWith('.uistate.json'));
            
            if (jFile && uFile) {
                try {
                    const jData = JSON.parse(await jFile.text());
                    const uData = JSON.parse(await uFile.text());
                    app.load(jData, uData);
                    document.getElementById('filename-display').textContent = jFile.name;
                    document.getElementById('status-bar').textContent = `${jData.nodes.length} nodes loaded`;
                } catch(err) { alert("Error parsing JSON: " + err.message); }
            } else {
                alert("Please select both .json and .uistate.json files");
            }
            e.target.value = ''; // Reset input to allow re-selection
        };

        // 3. MiniFlow Import Logic
        const fileInputMini = document.getElementById('file-input-mini');
        
        fileInputMini.onchange = async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            try {
                const text = await file.text();
                const json = JSON.parse(text);
                app.importMiniFlow(json);
            } catch (err) {
                alert("Error reading MiniFlow file: " + err.message);
                console.error(err);
            }
            e.target.value = ''; 
        };

        // 4. Edit Mode Controls
        document.getElementById('btn-toggle-mode').onclick = () => {
            if (app.state.mode === 'view') app.setMode('edit');
            else {
                app.rebuildConnectivity();
                app.setMode('view');
                document.getElementById('status-bar').textContent = 'Changes Saved locally (Memory)';
            }
        };

        document.getElementById('btn-cancel-edit').onclick = () => {
            app.data.flowchart = app.data.original; // Restore from backup
            app.setMode('view');
        };

        // 5. Save / Export C3 Logic
        const saveFile = () => {
            if (!app.data.flowchart) {
                alert("No flowchart data to export");
                return;
            }

            // Перестраиваем связи перед сохранением
            app.rebuildConnectivity();
            
            const download = (content, name) => {
                const a = document.createElement('a');
                a.href = URL.createObjectURL(new Blob([JSON.stringify(content, null, '\t')], {type: 'application/json'}));
                a.download = name; 
                a.click();
            };
            
            const name = app.data.flowchart.name || 'flowchart';
            download(app.data.flowchart, name + '.json');
            download(app.data.ui, name + '.uistate.json');
            
            // Если были в режиме редактирования — выходим (стандартное поведение Save)
            // Если в режиме просмотра (Export) — остаемся как есть
            if (app.state.mode === 'edit') {
                app.setMode('view');
            }
        };

        // 6. View Controls
        document.getElementById('btn-reset-view').onclick = () => { app.view.zoom = 1; app.view.panX=0; app.view.panY=0; app.render(); };

        // 7. Menu Item Bindings (File Menu)

        // -- Stubs --
        document.getElementById('btn-new').onclick = () => alert("New File: Функция пока не реализована (Заглушка)");
        document.getElementById('btn-open').onclick = () => alert("Open File: Функция пока не реализована (Заглушка)");
        
        const saveStubAction = () => alert("Save (Ctrl+S): Локальное сохранение пока не реализовано. Используйте Export.");
        document.getElementById('btn-save-stub').onclick = saveStubAction;
        
        const saveAsStubAction = () => alert("Save As (Shift+Ctrl+S): Функция пока не реализована. Используйте Export.");
        document.getElementById('btn-save-as-stub').onclick = saveAsStubAction;

        // -- Import --
        document.getElementById('btn-import-c3').onclick = () => fileInputC3.click();
        document.getElementById('btn-import-mini').onclick = () => fileInputMini.click();

        // -- Export --
        document.getElementById('btn-export-c3').onclick = () => saveFile(); // Export C3 (JSON + UIState)
        document.getElementById('btn-export-mini').onclick = () => {
             if (!app.data.flowchart) return alert("No flowchart to export");
             app.exportMiniFlow();
        };

        // 8. Hotkeys Handler
        
        // Перехват системного события копирования для очистки внутреннего буфера
        document.addEventListener('copy', (e) => {
            // Если событие произошло НЕ на body (например, в input или textarea), 
            // значит пользователь копирует текст.
            // Очищаем наш буфер нод, чтобы Ctrl+V потом не вставил ноду вместо текста.
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                app.clipboard = null;
            }
        });

        document.addEventListener('keydown', (e) => {
            // Игнорируем хоткеи, если фокус в поле ввода
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

            const isCtrl = e.ctrlKey || e.metaKey; // Windows Ctrl or Mac Cmd

            // Save: Ctrl+S
            if (isCtrl && e.code === 'KeyS') {
                e.preventDefault(); 
                if (e.shiftKey) {
                    saveAsStubAction();
                } else {
                    saveStubAction();
                }
            }

            // Copy: Ctrl+C
            if (isCtrl && e.code === 'KeyC') {
                // Копируем только если есть выделенная нода и мы в режиме редактирования
                if (app.state.mode === 'edit' && app.state.selection.node) {
                    // e.preventDefault() здесь не обязательно, но полезно, чтобы не копировать "ничего" в системный буфер
                    app.copyNode(app.state.selection.node);
                }
            }

            // Paste: Ctrl+V
            if (isCtrl && e.code === 'KeyV') {
                if (app.state.mode === 'edit' && app.clipboard) {
                    // Вставляем в позицию последнего известного положения мыши (относительно канваса)
                    // app.state.lastMouse хранит clientX/Y
                    const rect = app.canvas.getBoundingClientRect();
                    const mx = app.state.lastMouse.x - rect.left;
                    const my = app.state.lastMouse.y - rect.top;
                    
                    app.pasteNode(mx, my);
                }
            }
            
            // Delete: Del key
            if (e.code === 'Delete') {
                 if (app.state.mode === 'edit' && app.state.selection.node) {
                     app.deleteNode(app.state.selection.node);
                 }
            }
        });

        // 9. Toolbar Actions
        const toolAction = (id, fn) => document.getElementById(id).onclick = fn;
        toolAction('tool-add-node', () => app.addNode(app.canvas.width/2, app.canvas.height/2));
        toolAction('tool-del-node', () => app.deleteNode(app.state.selection.node));
        toolAction('tool-add-out', () => document.getElementById('prop-add-out').click());
        toolAction('tool-enable', () => { if(app.state.selection.node) { app.state.selection.node.e = !app.state.selection.node.e; app.generateProperties(app.state.selection.node); app.render(); }});
        toolAction('tool-start', () => { if(app.state.selection.node) { app.data.flowchart.nodes.forEach(n=>n.s=false); app.state.selection.node.s=true; app.generateProperties(app.state.selection.node); app.render(); }});

    </script>
</body>
</html>