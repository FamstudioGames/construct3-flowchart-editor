<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Construct 3 Flowchart Editor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
            background: #2b2b2b;
            color: #e0e0e0;
            overflow: hidden;
        }

        /* --- MENU BAR --- */
        #menu-bar {
            background: #3c3c3c;
            display: flex;
            font-size: 13px;
            border-bottom: 1px solid #1e1e1e;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1000;
            height: 30px;
            align-items: center;
            user-select: none;
        }

        .menu-item {
            padding: 0 15px;
            cursor: pointer;
            position: relative;
            height: 100%;
            display: flex;
            align-items: center;
        }

        .menu-item:hover { background: #505050; }
        .menu-item.active { background: #0078d4 !important; }

        .dropdown {
            display: none;
            position: absolute;
            top: 30px;
            left: 0;
            background: #2d2d2d;
            border: 1px solid #454545;
            min-width: 200px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
            z-index: 1001;
        }

        .dropdown-item { 
            padding: 8px 20px;
            cursor: pointer; 
            color: #e0e0e0; 
        }

        .dropdown-item:hover:not(.disabled) { background: #0078d4; }
        .dropdown-item.disabled { 
            cursor: default; 
            opacity: 0.5;
        }

        .separator {
            height: 1px; 
            background: #454545; 
            margin: 4px 0;
        }

        /* --- TOOLBAR --- */
        .toolbar {
            display: none;
            gap: 5px;
            padding: 10px;
            background: #1e1e1e;
            border-bottom: 1px solid #3a3a3a;
            flex-wrap: wrap;
            position: fixed;
            top: 30px;
            left: 0;
            right: 350px;
            z-index: 50;
        }

        .toolbar.active {
            display: flex;
        }

        .toolbar-group {
            display: flex;
            gap: 5px;
            padding-right: 10px;
            border-right: 1px solid #555;
        }

        .toolbar-group:last-child {
            border-right: none;
        }

        button {
            padding: 10px 20px;
            background: #0078d4;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
            transition: background 0.2s;
        }

        button.small-btn {
            padding: 4px 8px;
            font-size: 11px;
        }

        button:hover:not(:disabled) {
            background: #106ebe;
        }

        button:disabled {
            background: #555;
            cursor: not-allowed;
            opacity: 0.5;
        }

        /* --- CANVAS --- */
        #canvas-container {
            position: fixed;
            top: 30px;
            left: 0;
            right: 0; /* Default right, changed in JS for edit mode */
            bottom: 0;
            overflow: hidden;
            transition: right 0.2s;
        }

        canvas {
            cursor: grab;
            background: #2b2b2b;
        }

        canvas:active {
            cursor: grabbing;
        }

        canvas.editing {
            cursor: default;
        }

        /* --- PROPERTIES PANEL --- */
        #properties-panel {
            position: fixed;
            top: 30px;
            right: 0;
            width: 350px;
            bottom: 0;
            background: #1e1e1e;
            border-left: 1px solid #3a3a3a;
            overflow-y: auto;
            padding: 15px;
            display: none;
            z-index: 40;
        }

        #properties-panel.active {
            display: block;
        }

        .property-group {
            margin-bottom: 20px;
            padding-bottom: 20px;
            border-bottom: 1px solid #3a3a3a;
        }

        .property-group h3 {
            margin-bottom: 10px;
            color: #0078d4;
            font-size: 14px;
        }

        .property-row {
            margin-bottom: 10px;
        }

        .property-row label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
            color: #888;
        }

        .property-row input[type="text"],
        .property-row input[type="number"],
        .property-row textarea,
        .property-row select {
            width: 100%;
            padding: 8px;
            background: #333;
            border: 1px solid #555;
            border-radius: 4px;
            color: #e0e0e0;
            font-family: inherit;
        }

        .property-row input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .property-row input[type="color"] {
            width: 100%;
            height: 40px;
            cursor: pointer;
            border: 1px solid #555;
            border-radius: 4px;
        }

        /* --- OUTPUT ITEMS --- */
        .output-item {
            background: #2a2a2a;
            padding: 10px;
            margin-bottom: 10px;
            border-radius: 4px;
            border-left: 3px solid #0078d4;
        }

        .output-item.default {
            border-left-color: #4caf50;
        }

        .output-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .output-item-controls {
            display: flex;
            gap: 5px;
        }

        /* --- CONTEXT MENU --- */
        .context-menu {
            position: fixed;
            background: #2a2a2a;
            border: 1px solid #555;
            border-radius: 4px;
            padding: 5px 0;
            z-index: 2000;
            display: none;
            min-width: 180px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
        }

        .context-menu.active {
            display: block;
        }

        .context-menu-item {
            padding: 8px 15px;
            cursor: pointer;
            font-size: 13px;
            transition: background 0.2s;
        }

        .context-menu-item:hover {
            background: #3a3a3a;
        }

        .context-menu-item.separator {
            border-top: 1px solid #555;
            margin: 5px 0;
            padding: 0;
            cursor: default;
        }

        /* --- MISC --- */
        .selection-rect {
            stroke: #0078d4;
            stroke-width: 2;
            stroke-dasharray: 5, 5;
            fill: rgba(0, 120, 212, 0.1);
        }

        #mode-indicator {
            position: fixed;
            top: 40px;
            left: 10px;
            background: rgba(30, 30, 30, 0.9);
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            z-index: 50;
            font-weight: bold;
        }

        #mode-indicator.view-mode { color: #4caf50; }
        #mode-indicator.edit-mode { color: #ff9800; }

        .zoom-info {
            position: fixed;
            bottom: 10px;
            left: 10px;
            background: rgba(30, 30, 30, 0.9);
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            z-index: 50;
        }

        .property-row textarea {
            min-height: 60px;
            resize: vertical;
            font-family: monospace;
            line-height: 1.4;
        }
    </style>
</head>
<body>
    <!-- MENU BAR -->
    <div id="menu-bar">
        <!-- File Menu -->
        <div class="menu-item" id="fileMenuBtn">
            File
            <div class="dropdown" id="fileDropdown">
                <div id="importTrigger" class="dropdown-item">Import (*.json, *.uistate.json)</div>
                <div class="separator"></div>
                <div id="menuSaveBtn" class="dropdown-item disabled">Save</div>
                <div id="menuSaveAsBtn" class="dropdown-item disabled">Save As...</div>
            </div>
        </div>

        <!-- Edit Menu -->
        <div class="menu-item" id="editMenuBtn" style="opacity: 0.5; pointer-events: none;">
            Edit
            <div class="dropdown" id="editDropdown">
                <div id="toggleEditModeBtn" class="dropdown-item">Enter Edit Mode</div>
                <div id="menuCancelEditBtn" class="dropdown-item" style="color: #ff5555; display: none;">Cancel Editing</div>
            </div>
        </div>

        <!-- View Menu -->
        <div class="menu-item" id="viewMenuBtn">
            View
            <div class="dropdown" id="viewDropdown">
                <div id="menuResetViewBtn" class="dropdown-item">Reset View</div>
            </div>
        </div>

        <!-- Status Info -->
        <div id="status" style="margin-left: 20px; font-size: 11px; color: #aaa;">No flowchart imported</div>
        <div id="current-filename" style="margin-left: auto; padding-right: 15px; color: #0078d4; font-size: 11px; font-weight: bold;"></div>
    </div>

    <!-- TOOLBAR (Edit Mode Only) -->
    <div class="toolbar" id="toolbar">
        <div class="toolbar-group">
            <button class="small-btn" id="addNodeBtn">Add Node</button>
            <button class="small-btn" id="deleteNodeBtn" disabled>Delete Node</button>
        </div>
        <div class="toolbar-group">
            <button class="small-btn" id="addOutputBtn" disabled>Add Output</button>
            <button class="small-btn" id="deleteOutputBtn" disabled>Delete Output</button>
        </div>
        <div class="toolbar-group">
            <button class="small-btn" id="enableNodeBtn" disabled>Enable/Disable</button>
            <button class="small-btn" id="setStartBtn" disabled>Set as Start</button>
        </div>
    </div>

    <!-- Hidden File Input -->
    <input type="file" id="jsonFiles" accept=".json" multiple style="display: none;">

    <div id="mode-indicator" class="view-mode">VIEW MODE</div>

    <div id="canvas-container">
        <canvas id="canvas"></canvas>
    </div>

    <div id="properties-panel">
        <div class="property-group">
            <h3>No Selection</h3>
            <p style="color: #888; font-size: 13px;">Select a node or output to edit properties</p>
        </div>
    </div>

    <div class="zoom-info">
        <div>Zoom: <span id="zoomLevel">100%</span></div>
        <div>Pan: Drag | Zoom: Ctrl+Scroll</div>
        <div id="editHint" style="display: none; margin-top: 5px; color: #ff9800;">
            Right-click for options
        </div>
    </div>

    <div id="contextMenu" class="context-menu"></div>

    <script>
        class FlowchartEditor {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                if (!this.canvas) {
                    console.error(`Canvas element with id "${canvasId}" not found!`);
                    return;
                }
                this.ctx = this.canvas.getContext('2d');
                this.flowchartData = null;
                this.uiStateData = null;
                this.originalData = null;
                
                this.zoom = 1;
                this.panX = 0;
                this.panY = 0;
                this.isDragging = false;
                this.lastMouseX = 0;
                this.lastMouseY = 0;

                this.editMode = false;
                this.selectedNode = null;
                this.selectedOutput = null;
                this.selectedOutputIndex = -1;
                this.draggedNode = null;
                this.connectionStart = null;
                this.hoveredNode = null;
                this.hoveredOutput = null;
                this.selectionRect = null;

                this.setupCanvas();
                this.setupEventListeners();
            }

            setupCanvas() {
                const container = this.canvas.parentElement;
                if (!container) return;
                this.canvas.width = container.clientWidth;
                this.canvas.height = container.clientHeight;
            }

            setupEventListeners() {
                window.addEventListener('resize', () => {
                    this.setupCanvas();
                    this.render();
                });
                
                this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                this.canvas.addEventListener('mouseup', (e) => this.handleMouseUp(e));
                this.canvas.addEventListener('mouseleave', () => {
                    this.isDragging = false;
                    this.draggedNode = null;
                });

                this.canvas.addEventListener('wheel', (e) => {
                    if (e.ctrlKey) {
                        e.preventDefault();
                        const delta = e.deltaY > 0 ? 0.9 : 1.1;
                        this.zoom *= delta;
                        this.zoom = Math.max(0.1, Math.min(5, this.zoom));
                        document.getElementById('zoomLevel').textContent = Math.round(this.zoom * 100) + '%';
                        this.render();
                    }
                });

                this.canvas.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    if (this.editMode) {
                        this.showContextMenu(e);
                    }
                });

                // Close context menu on click outside
                document.addEventListener('click', () => {
                    const ctxMenu = document.getElementById('contextMenu');
                    if(ctxMenu) ctxMenu.classList.remove('active');
                });
            }

            handleMouseDown(e) {
                const rect = this.canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                if (this.editMode) {
                    // Check if clicking on a node
                    const clickedNode = this.getNodeAtPosition(mouseX, mouseY);
                    if (clickedNode) {
                        // Check if clicking on output
                        const output = this.getOutputAtPosition(clickedNode, mouseX, mouseY);
                        if (output) {
                            this.connectionStart = { node: clickedNode, output: output };
                        } else {
                            this.selectNode(clickedNode);
                            this.draggedNode = clickedNode;
                        }
                        this.render();
                        return;
                    } else {
                        this.deselectAll();
                    }
                }

                // Pan mode
                this.isDragging = true;
                this.lastMouseX = e.clientX;
                this.lastMouseY = e.clientY;
            }

            handleMouseMove(e) {
                const rect = this.canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                // 1. Pan (Перемещение холста)
                if (this.isDragging && !this.editMode) {
                    const dx = e.clientX - this.lastMouseX;
                    const dy = e.clientY - this.lastMouseY;
                    this.panX += dx;
                    this.panY += dy;
                    this.lastMouseX = e.clientX;
                    this.lastMouseY = e.clientY;
                    this.render();
                    return;
                } 
                
                // 2. Drag Node (Перемещение ноды)
                if (this.draggedNode && this.editMode) {
                    const worldPos = this.screenToWorld(mouseX, mouseY);
                    this.draggedNode.x = worldPos.x - this.draggedNode.w / 2;
                    this.draggedNode.y = worldPos.y - 15;
                    this.render();
                    return;
                } 
                
                // 3. Creating Connection (Тянем связь)
                if (this.connectionStart) {
                    // Обновляем hoveredNode для подсветки цели
                    this.hoveredNode = this.getNodeAtPosition(mouseX, mouseY);
                    
                    // Если не нашли точно под курсором, ищем ближайшую
                    if (!this.hoveredNode) {
                        this.hoveredNode = this.getClosestNodeNearPosition(mouseX, mouseY, 50);
                    }
                    
                    // Проверяем, что это не та же самая нода
                    if (this.hoveredNode === this.connectionStart.node) {
                        this.hoveredNode = null;
                    }
                    
                    this.render();
                    
                    // Рисуем пунктирную линию
                    const startPos = this.getOutputPosition(this.connectionStart.node, 
                        this.connectionStart.node.outputs.indexOf(this.connectionStart.output));
                    this.ctx.save();
                    this.ctx.strokeStyle = '#ffffff';
                    this.ctx.lineWidth = 2;
                    this.ctx.setLineDash([5, 5]);
                    this.ctx.beginPath();
                    this.ctx.moveTo(startPos.x, startPos.y);
                    
                    // Если есть hoveredNode, рисуем линию до центра левой стороны ноды
                    if (this.hoveredNode) {
                        const endPos = this.worldToScreen(this.hoveredNode.x, 
                            this.hoveredNode.y + this.hoveredNode.h / 2);
                        this.ctx.lineTo(endPos.x, endPos.y);
                    } else {
                        // Иначе рисуем до курсора
                        this.ctx.lineTo(mouseX, mouseY);
                    }
                    
                    this.ctx.stroke();
                    this.ctx.restore();
                    return;
                }

                // 4. Hover State (Обычный режим редактирования)
                if (this.editMode) {
                    this.hoveredNode = this.getNodeAtPosition(mouseX, mouseY);
                    
                    if (this.hoveredNode) {
                        this.hoveredOutput = this.getOutputAtPosition(this.hoveredNode, mouseX, mouseY);
                        this.hoveredConnection = null;
                    } else {
                        this.hoveredOutput = null;
                        this.hoveredConnection = this.getConnectionAtPosition(mouseX, mouseY);
                    }
                    this.render();
                }
            }

            // --- НОВЫЙ МЕТОД: Поиск связи под курсором ---
            getConnectionAtPosition(mouseX, mouseY) {
                if (!this.flowchartData?.nodes) return null;
                const threshold = 5; // Дистанция захвата

                for (const node of this.flowchartData.nodes) {
                    if (!node.outputs) continue;
                    for (let i = 0; i < node.outputs.length; i++) {
                        const output = node.outputs[i];
                        if (output.cnSID && output.enable) {
                            const targetNode = this.flowchartData.nodes.find(n => n.sid === output.cnSID);
                            if (targetNode) {
                                const start = this.getOutputPosition(node, i);
                                // Вход в целевую ноду всегда слева по центру
                                const end = this.worldToScreen(targetNode.x, targetNode.y + (targetNode.h / 2));
                                
                                // Проверяем дистанцию до кривой Безье
                                if (this.isPointNearBezier(mouseX, mouseY, start, end, threshold)) {
                                    return { node, output, index: i };
                                }
                            }
                        }
                    }
                }
                return null;
            }

            // --- НОВЫЙ МЕТОД: Математика попадания в кривую ---
            isPointNearBezier(px, py, p0, p3, threshold) {
                // Контрольные точки (такие же как при рисовании)
                const cpDist = Math.abs(p3.x - p0.x) * 0.5;
                const p1 = { x: p0.x + cpDist, y: p0.y };
                const p2 = { x: p3.x - cpDist, y: p3.y };

                // Проходим по кривой с шагом (не идеально точно, но быстро)
                const steps = 20;
                for (let i = 0; i <= steps; i++) {
                    const t = i / steps;
                    const it = 1 - t;
                    // Формула кубической кривой Безье
                    const x = it*it*it*p0.x + 3*it*it*t*p1.x + 3*it*t*t*p2.x + t*t*t*p3.x;
                    const y = it*it*it*p0.y + 3*it*it*t*p1.y + 3*it*t*t*p2.y + t*t*t*p3.y;

                    const dist = Math.sqrt((px - x)**2 + (py - y)**2);
                    if (dist < threshold) return true;
                }
                return false;
            }

           handleMouseUp(e) {
                const rect = this.canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                // Если мы тащили связь
                if (this.connectionStart) {
                    // ИСПРАВЛЕНИЕ: Вместо того чтобы заново искать ноду по строгим координатам (getNodeAtPositionFromWorld),
                    // мы используем this.hoveredNode. Эта переменная обновляется в handleMouseMove и уже содержит 
                    // правильную целевую ноду с учетом дистанции "примагничивания" (snapping).
                    const targetNode = this.hoveredNode;
                    
                    // Если нашли ноду (targetNode) и это не та же самая нода
                    if (targetNode && targetNode !== this.connectionStart.node) {
                        const sourceNode = this.connectionStart.node;
                        const output = this.connectionStart.output;

                        // 1. Присваиваем выходу ID целевой ноды
                        output.cnSID = targetNode.sid;

                        // 2. Обновляем списки входящих связей у целевой ноды
                        if (!targetNode.pnSIDs) targetNode.pnSIDs = [];
                        if (!targetNode.poSIDs) targetNode.poSIDs = [];

                        // Добавляем ID родительской ноды, если его там нет
                        if (!targetNode.pnSIDs.includes(sourceNode.sid)) {
                            targetNode.pnSIDs.push(sourceNode.sid);
                        }
                        // Добавляем ID выхода, если его там нет
                        if (!targetNode.poSIDs.includes(output.sid)) {
                            targetNode.poSIDs.push(output.sid);
                        }
                    }
                    
                    // Сброс состояния
                    this.connectionStart = null;
                    this.hoveredNode = null;
                    this.render();
                }

                this.isDragging = false;
                this.draggedNode = null;
            }

            getNodeAtPositionFromWorld(worldX, worldY) {
                if (!this.flowchartData || !this.flowchartData.nodes) return null;
                
                // Идем с конца массива (чтобы выбирать верхнюю ноду, если они перекрываются)
                for (let i = this.flowchartData.nodes.length - 1; i >= 0; i--) {
                    const node = this.flowchartData.nodes[i];
                    
                    // Простая проверка попадания точки в прямоугольник в мировых координатах
                    if (worldX >= node.x && 
                        worldX <= node.x + node.w &&
                        worldY >= node.y && 
                        worldY <= node.y + node.h) {
                        return node;
                    }
                }
                return null;
            }

            getClosestNodeNearPosition(screenX, screenY, maxDistance = 50) {
                if (!this.flowchartData || !this.flowchartData.nodes) return null;
                
                const worldPos = this.screenToWorld(screenX, screenY);
                let closestNode = null;
                let closestDistance = Infinity;
                
                // Ищем самую близкую ноду в пределах maxDistance
                for (const node of this.flowchartData.nodes) {
                    // Центр ноды
                    const centerX = node.x + node.w / 2;
                    const centerY = node.y + node.h / 2;
                    
                    // Расстояние до центра ноды
                    const distance = Math.sqrt(
                        Math.pow(worldPos.x - centerX, 2) + 
                        Math.pow(worldPos.y - centerY, 2)
                    );
                    
                    if (distance < closestDistance && distance < maxDistance) {
                        closestDistance = distance;
                        closestNode = node;
                    }
                }
                
                return closestNode;
            }

            screenToWorld(screenX, screenY) {
                return {
                    x: (screenX - this.panX) / this.zoom,
                    y: (screenY - this.panY) / this.zoom
                };
            }

            worldToScreen(x, y) {
                return {
                    x: x * this.zoom + this.panX,
                    y: y * this.zoom + this.panY
                };
            }

            getNodeAtPosition(screenX, screenY) {
                if (!this.flowchartData || !this.flowchartData.nodes) return null;
                
                // Переводим координаты экрана в координаты мира (с учетом зума и панорамирования)
                const worldPos = this.screenToWorld(screenX, screenY);
                
                // Идем с конца массива (чтобы выбирать верхнюю ноду, если они перекрываются)
                for (let i = this.flowchartData.nodes.length - 1; i >= 0; i--) {
                    const node = this.flowchartData.nodes[i];
                    
                    // Простая проверка попадания точки в прямоугольник
                    if (worldPos.x >= node.x && 
                        worldPos.x <= node.x + node.w &&
                        worldPos.y >= node.y && 
                        worldPos.y <= node.y + node.h) {
                        return node;
                    }
                }
                return null;
            }

            getOutputAtPosition(node, screenX, screenY) {
                if (!node.outputs) return null;
                
                const pos = this.worldToScreen(node.x, node.y);
                const width = node.w * this.zoom;
                const headerHeight = 30 * this.zoom;
                
                // Рассчитываем стартовую Y позицию для выходов
                const startY = pos.y + headerHeight + (node.t ? 20 * this.zoom : 5 * this.zoom);
                
                for (let i = 0; i < node.outputs.length; i++) {
                    // Позиция кружочка подключения (справа от ноды)
                    const outputY = startY + (i * 24 * this.zoom) + (12 * this.zoom);
                    const outputX = pos.x + width;
                    
                    // Расстояние до кружочка подключения
                    const dist = Math.sqrt(Math.pow(screenX - outputX, 2) + Math.pow(screenY - outputY, 2));
                    
                    // Увеличиваем область клика (было 10, станет 15 с учетом zoom)
                    if (dist < 15 * this.zoom) {
                        return { output: node.outputs[i], index: i };
                    }
                }
                return null;
            }

            getOutputPosition(node, outputIndex) {
                const outputY = node.y + 60 + (outputIndex * 30);
                return this.worldToScreen(node.x + node.w, outputY);
            }

            selectNode(node) {
                this.selectedNode = node;
                this.selectedOutput = null;
                this.selectedOutputIndex = -1;
                this.updatePropertiesPanel();
                this.updateToolbarButtons();
            }

            deselectAll() {
                this.selectedNode = null;
                this.selectedOutput = null;
                this.selectedOutputIndex = -1;
                this.updatePropertiesPanel();
                this.updateToolbarButtons();
                this.render();
            }

            updateToolbarButtons() {
                const hasNode = this.selectedNode !== null;
                const delNodeBtn = document.getElementById('deleteNodeBtn');
                const addOutBtn = document.getElementById('addOutputBtn');
                const delOutBtn = document.getElementById('deleteOutputBtn');
                const enNodeBtn = document.getElementById('enableNodeBtn');
                const startBtn = document.getElementById('setStartBtn');

                if(delNodeBtn) delNodeBtn.disabled = !hasNode;
                if(addOutBtn) addOutBtn.disabled = !hasNode;
                if(delOutBtn) delOutBtn.disabled = !hasNode || !this.selectedOutput;
                if(enNodeBtn) enNodeBtn.disabled = !hasNode;
                if(startBtn) startBtn.disabled = !hasNode;
            }

            showContextMenu(e) {
                const menu = document.getElementById('contextMenu');
                
                let menuItems = [];

                // 1. Если клик по СВЯЗИ
                if (this.hoveredConnection) {
                    menuItems = [
                        { 
                            label: 'Delete Connection', 
                            action: () => this.deleteConnection(this.hoveredConnection) 
                        }
                    ];
                }
                // 2. Если клик по НОДЕ
                else {
                    const rect = this.canvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;
                    const clickedNode = this.getNodeAtPosition(mouseX, mouseY);

                    if (clickedNode) {
                        menuItems = [
                            { label: 'Add Output', action: () => this.addOutput(clickedNode) },
                            { label: 'Delete Node', action: () => this.deleteNode(clickedNode) },
                            { separator: true },
                            { label: clickedNode.e ? 'Disable Node' : 'Enable Node', 
                            action: () => this.toggleNodeEnabled(clickedNode) },
                            { label: 'Set as Start Node', action: () => this.setStartNode(clickedNode) },
                            { separator: true },
                            { label: 'Edit Caption', action: () => this.editCaption(clickedNode) },
                        ];
                    } else {
                        menuItems = [
                            { label: 'Add Node', action: () => this.addNodeAt(mouseX, mouseY) },
                        ];
                    }
                }

                // Рендер меню
                menu.innerHTML = menuItems.map(item => {
                    if (item.separator) {
                        return '<div class="context-menu-item separator"></div>';
                    }
                    return `<div class="context-menu-item" data-action="${menuItems.indexOf(item)}">${item.label}</div>`;
                }).join('');

                menu.style.left = e.clientX + 'px';
                menu.style.top = e.clientY + 'px';
                menu.classList.add('active');

                // Обработчики
                menu.querySelectorAll('.context-menu-item:not(.separator)').forEach(item => {
                    item.addEventListener('click', (evt) => {
                        evt.stopPropagation();
                        const index = parseInt(item.dataset.action);
                        menuItems[index].action();
                        menu.classList.remove('active');
                    });
                });
            }

             // --- НОВЫЙ МЕТОД: Удаление связи ---
            deleteConnection(connectionInfo) {
                if (!connectionInfo || !connectionInfo.output) return;
                
                // Разрываем связь
                connectionInfo.output.cnSID = null;
                
                // Также нужно удалить pnSID у целевой ноды (для чистоты данных, хотя Construct 3 может это перестроить сам)
                // Но в JSON структуре pnSIDs (Parent Node SIDs) хранит входящие.
                // Это сложнее отследить, но для визуального разрыва достаточно cnSID = null.
                
                this.hoveredConnection = null;
                this.render();
            }

            addNodeAt(screenX, screenY) {
                const worldPos = this.screenToWorld(screenX, screenY);
                const newNode = {
                    sid: Date.now() + Math.floor(Math.random() * 1000000),
                    pnSIDs: [],
                    poSIDs: [],
                    nodeSIDs: [],
                    outputs: [
                        {
                            sid: Date.now() + Math.floor(Math.random() * 1000000) + 1,
                            cnSID: null,
                            name: "Option 1",
                            value: "Value 1",
                            enable: true,
                            default: false
                        }
                    ],
                    x: worldPos.x - 210,
                    y: worldPos.y - 66,
                    w: 420,
                    h: 132,
                    t: "",
                    s: false,
                    e: true,
                    pi: 0,
                    c: "New Node",
                    ty: "dictionary",
                    pr: false,
                    prfsid: null,
                    prfnsid: null
                };

                this.flowchartData.nodes.push(newNode);
                
                // Add UI state
                if (!this.uiStateData.nodes) this.uiStateData.nodes = [];
                this.uiStateData.nodes.push({
                    node: {
                        propertiesBar: {},
                        nodeTable: {},
                        color: [0.8, 0.8, 0.8, 1]
                    },
                    outputs: [{
                        color: [0, 0, 0, 1],
                        linkMode: "line",
                        propertiesBar: {}
                    }]
                });

                this.selectNode(newNode);
                this.render();
            }

            addOutput(node) {
                if (!node) node = this.selectedNode;
                if (!node) return;

                const newOutput = {
                    sid: Date.now() + Math.floor(Math.random() * 1000000),
                    cnSID: null,
                    name: `Option ${node.outputs.length + 1}`,
                    value: `Value ${node.outputs.length + 1}`,
                    enable: true,
                    default: false
                };

                node.outputs.push(newOutput);
                node.h += 30;

                // Update UI state
                const nodeIndex = this.flowchartData.nodes.indexOf(node);
                if (this.uiStateData.nodes[nodeIndex]) {
                    this.uiStateData.nodes[nodeIndex].outputs.push({
                        color: [0, 0, 0, 1],
                        linkMode: "line",
                        propertiesBar: {}
                    });
                }

                this.selectNode(node);
                this.render();
            }

            deleteNode(node) {
                if (!node) node = this.selectedNode;
                if (!node) return;

                const index = this.flowchartData.nodes.indexOf(node);
                if (index > -1) {
                    // Remove connections
                    this.flowchartData.nodes.forEach(n => {
                        if (n.outputs) {
                            n.outputs.forEach(output => {
                                if (output.cnSID === node.sid) {
                                    output.cnSID = null;
                                }
                            });
                        }
                        if (n.pnSIDs) {
                            n.pnSIDs = n.pnSIDs.filter(sid => sid !== node.sid);
                        }
                    });

                    this.flowchartData.nodes.splice(index, 1);
                    if (this.uiStateData.nodes) {
                        this.uiStateData.nodes.splice(index, 1);
                    }
                    
                    this.deselectAll();
                    this.render();
                }
            }

            toggleNodeEnabled(node) {
                if (!node) node = this.selectedNode;
                if (!node) return;

                node.e = !node.e;
                this.updatePropertiesPanel();
                this.render();
            }

            setStartNode(node) {
                if (!node) node = this.selectedNode;
                if (!node) return;

                // Remove start from all other nodes
                this.flowchartData.nodes.forEach(n => n.s = false);
                node.s = true;
                this.render();
            }

            editCaption(node) {
                if (!node) node = this.selectedNode;
                if (!node) return;

                const newCaption = prompt('Enter new caption:', node.c);
                if (newCaption !== null) {
                    node.c = newCaption;
                    this.updatePropertiesPanel();
                    this.render();
                }
            }

            updatePropertiesPanel() {
                const panel = document.getElementById('properties-panel');
                
                if (!this.selectedNode) {
                    panel.innerHTML = `
                        <div class="property-group">
                            <h3>No Selection</h3>
                            <p style="color: #888; font-size: 13px;">Select a node to edit properties</p>
                        </div>
                    `;
                    return;
                }

                const node = this.selectedNode;
                const nodeIndex = this.flowchartData.nodes.indexOf(node);

                panel.innerHTML = `
                    <div class="property-group">
                        <h3>Node Properties</h3>
                        <div class="property-row">
                            <label>Caption</label>
                            <input type="text" id="prop-caption" value="${node.c || ''}" />
                        </div>
                        <div class="property-row">
                            <label>Tags (space-separated)</label>
                            <input type="text" id="prop-tags" value="${node.t || ''}" />
                        </div>
                        <div class="property-row">
                            <label>
                                <input type="checkbox" id="prop-enabled" ${node.e ? 'checked' : ''} />
                                Enabled
                            </label>
                        </div>
                        <div class="property-row">
                            <label>
                                <input type="checkbox" id="prop-start" ${node.s ? 'checked' : ''} />
                                Start Node
                            </label>
                        </div>
                        <div class="property-row">
                            <label>Border Color</label>
                            <input type="color" id="prop-color" />
                        </div>
                    </div>

                    <div class="property-group">
                        <h3>Outputs</h3>
                        <div id="outputs-list"></div>
                        <button class="small-btn" id="add-output-btn" style="margin-top: 10px; width: 100%;">Add Output</button>
                    </div>
                `;

                // Set color value
                if (this.uiStateData.nodes[nodeIndex]?.node?.color) {
                    const c = this.uiStateData.nodes[nodeIndex].node.color;
                    const hex = '#' + [c[0], c[1], c[2]].map(v => 
                        Math.round(v * 255).toString(16).padStart(2, '0')
                    ).join('');
                    document.getElementById('prop-color').value = hex;
                }

                // Add event listeners
                document.getElementById('prop-caption').addEventListener('input', (e) => {
                    node.c = e.target.value;
                    this.render();
                });

                document.getElementById('prop-tags').addEventListener('input', (e) => {
                    node.t = e.target.value;
                    this.render();
                });

                document.getElementById('prop-enabled').addEventListener('change', (e) => {
                    node.e = e.target.checked;
                    this.render();
                });

                document.getElementById('prop-start').addEventListener('change', (e) => {
                    if (e.target.checked) {
                        this.flowchartData.nodes.forEach(n => n.s = false);
                        node.s = true;
                    }
                    this.render();
                });

                document.getElementById('prop-color').addEventListener('input', (e) => {
                    const hex = e.target.value;
                    const r = parseInt(hex.slice(1, 3), 16) / 255;
                    const g = parseInt(hex.slice(3, 5), 16) / 255;
                    const b = parseInt(hex.slice(5, 7), 16) / 255;
                    
                    if (!this.uiStateData.nodes[nodeIndex]) {
                        this.uiStateData.nodes[nodeIndex] = { node: {}, outputs: [] };
                    }
                    if (!this.uiStateData.nodes[nodeIndex].node) {
                        this.uiStateData.nodes[nodeIndex].node = {};
                    }
                    this.uiStateData.nodes[nodeIndex].node.color = [r, g, b, 1];
                    this.render();
                });

                document.getElementById('add-output-btn').addEventListener('click', () => {
                    this.addOutput(node);
                });

                // Render outputs
                this.renderOutputsList(node, nodeIndex);
            }

            renderOutputsList(node, nodeIndex) {
                const container = document.getElementById('outputs-list');
                if (!container) return;

                container.innerHTML = node.outputs.map((output, i) => {
                    // Подготавливаем значение для отображения: заменяем символы \n на реальные переносы
                    const displayValue = (output.value || '').replace(/\\n/g, '\n');

                    return `
                    <div class="output-item ${output.default ? 'default' : ''}">
                        <div class="output-item-header">
                            <strong>Output ${i + 1}</strong>
                            <div class="output-item-controls">
                                <button class="small-btn" data-output="${i}" data-action="delete">Delete</button>
                            </div>
                        </div>
                        <div class="property-row">
                            <label>Name</label>
                            <input type="text" data-output="${i}" data-field="name" value="${output.name || ''}" />
                        </div>
                        <div class="property-row">
                            <label>Value (Multi-line)</label>
                            <textarea data-output="${i}" data-field="value">${displayValue}</textarea>
                        </div>
                        <div class="property-row">
                            <label>
                                <input type="checkbox" data-output="${i}" data-field="enabled" ${output.enable ? 'checked' : ''} />
                                Enabled
                            </label>
                        </div>
                        <div class="property-row">
                            <label>
                                <input type="checkbox" data-output="${i}" data-field="default" ${output.default ? 'checked' : ''} />
                                Default Output
                            </label>
                        </div>
                    </div>
                `}).join('');

                // Обработчики событий
                container.querySelectorAll('[data-output]').forEach(input => {
                    const outputIndex = parseInt(input.dataset.output);
                    const field = input.dataset.field;

                    if (input.type === 'checkbox') {
                        input.addEventListener('change', (e) => {
                            if (field === 'enabled') {
                                node.outputs[outputIndex].enable = e.target.checked;
                            } else if (field === 'default') {
                                node.outputs.forEach(o => o.default = false);
                                node.outputs[outputIndex].default = e.target.checked;
                            }
                            this.renderOutputsList(node, nodeIndex);
                            this.render();
                        });
                    } else if (input.tagName.toLowerCase() === 'textarea') {
                        // Обработка Textarea
                        input.addEventListener('input', (e) => {
                            // При сохранении заменяем реальные переносы обратно на символы \n
                            const rawValue = e.target.value;
                            node.outputs[outputIndex][field] = rawValue.replace(/\n/g, '\\n');
                            this.render();
                        });
                    } else {
                        // Обычные инпуты (Name)
                        input.addEventListener('input', (e) => {
                            node.outputs[outputIndex][field] = e.target.value;
                            this.render();
                        });
                    }
                });

                container.querySelectorAll('button[data-action="delete"]').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const outputIndex = parseInt(btn.dataset.output);
                        node.outputs.splice(outputIndex, 1);
                        node.h -= 30;
                        if (this.uiStateData.nodes[nodeIndex]?.outputs) {
                            this.uiStateData.nodes[nodeIndex].outputs.splice(outputIndex, 1);
                        }
                        this.renderOutputsList(node, nodeIndex);
                        this.render();
                    });
                });
            }

            enterEditMode() {
                this.editMode = true;
                this.originalData = {
                    flowchart: JSON.parse(JSON.stringify(this.flowchartData)),
                    uistate: JSON.parse(JSON.stringify(this.uiStateData))
                };

                this.canvas.classList.add('editing');
                document.getElementById('toolbar').classList.add('active');
                document.getElementById('properties-panel').classList.add('active');
                document.getElementById('editHint').style.display = 'block';
                
                const modeIndicator = document.getElementById('mode-indicator');
                modeIndicator.textContent = 'EDIT MODE';
                modeIndicator.className = 'edit-mode';
                
                // Adjust canvas container to make room for properties panel
                document.getElementById('canvas-container').style.right = '350px';
                
                this.setupCanvas();
                this.render();
            }

            exitEditMode(save = false) {
                if (!save) {
                    // Restore original data
                    this.flowchartData = this.originalData.flowchart;
                    this.uiStateData = this.originalData.uistate;
                }

                this.editMode = false;
                this.originalData = null;
                this.deselectAll();

                this.canvas.classList.remove('editing');
                document.getElementById('toolbar').classList.remove('active');
                document.getElementById('properties-panel').classList.remove('active');
                document.getElementById('editHint').style.display = 'none';
                
                const modeIndicator = document.getElementById('mode-indicator');
                modeIndicator.textContent = 'VIEW MODE';
                modeIndicator.className = 'view-mode';
                
                document.getElementById('canvas-container').style.right = '0';
                this.setupCanvas();
                this.render();
            }

            saveFlowchart() {
                // Update the loaded files
                app.jsonData = this.flowchartData;
                app.uistateData = this.uiStateData;
                
                document.getElementById('status').textContent = 'Changes saved';
                this.exitEditMode(true);
            }

            saveFlowchartAs() {
                const jsonStr = JSON.stringify(this.flowchartData, null, '\t');
                const uistateStr = JSON.stringify(this.uiStateData, null, '\t');

                // Download JSON file
                const jsonBlob = new Blob([jsonStr], { type: 'application/json' });
                const jsonUrl = URL.createObjectURL(jsonBlob);
                const jsonLink = document.createElement('a');
                jsonLink.href = jsonUrl;
                jsonLink.download = this.flowchartData.name + '.json';
                jsonLink.click();

                // Download uistate file
                const uistateBlob = new Blob([uistateStr], { type: 'application/json' });
                const uistateUrl = URL.createObjectURL(uistateBlob);
                const uistateLink = document.createElement('a');
                uistateLink.href = uistateUrl;
                uistateLink.download = this.flowchartData.name + '.uistate.json';
                uistateLink.click();

                document.getElementById('status').textContent = 'Files downloaded';
                this.exitEditMode(true);
            }

            loadFlowchart(flowchartData, uiStateData) {
                this.flowchartData = flowchartData;
                this.uiStateData = uiStateData;
                
                if (uiStateData && uiStateData.flowchart) {
                    this.zoom = uiStateData.flowchart.z || 1;
                    document.getElementById('zoomLevel').textContent = Math.round(this.zoom * 100) + '%';
                }

                this.centerView();
                this.render();
            }

            centerView() {
                if (!this.flowchartData || !this.flowchartData.nodes || this.flowchartData.nodes.length === 0) {
                    this.panX = this.canvas.width / 2;
                    this.panY = this.canvas.height / 2;
                    return;
                }

                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                
                this.flowchartData.nodes.forEach(node => {
                    minX = Math.min(minX, node.x);
                    minY = Math.min(minY, node.y);
                    maxX = Math.max(maxX, node.x + node.w);
                    maxY = Math.max(maxY, node.y + node.h);
                });

                const centerX = (minX + maxX) / 2;
                const centerY = (minY + maxY) / 2;

                this.panX = this.canvas.width / 2 - centerX * this.zoom;
                this.panY = this.canvas.height / 2 - centerY * this.zoom;
            }

            resetView() {
                this.zoom = 1;
                document.getElementById('zoomLevel').textContent = '100%';
                this.centerView();
                this.render();
            }

            render() {
                if (!this.flowchartData) return;

                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.save();

                this.drawConnections();
                this.drawNodes();

                this.ctx.restore();
            }

            drawConnections() {
                if (!this.flowchartData.nodes) return;

                this.flowchartData.nodes.forEach(node => {
                    if (!node.outputs) return;

                    node.outputs.forEach((output, outputIndex) => {
                        if (output.cnSID && output.enable) {
                            const targetNode = this.flowchartData.nodes.find(n => n.sid === output.cnSID);
                            if (targetNode) {
                                this.drawConnection(node, targetNode, outputIndex, output);
                            }
                        }
                    });
                });
            }

             drawConnection(fromNode, toNode, outputIndex, output) {
                // Координаты старта (справа от выхода)
                const startPos = this.getOutputPosition(fromNode, outputIndex);
                // Координаты конца (центр левой грани целевой ноды)
                const endPos = this.worldToScreen(toNode.x, toNode.y + (toNode.h / 2));

                // Определение цвета
                let color = '#666';
                let width = 2;

                // Если эта связь под курсором
                const isHovered = this.hoveredConnection && 
                                this.hoveredConnection.output === output;

                if (isHovered) {
                    color = '#ff9800'; // Оранжевый при наведении
                    width = 4;
                } else if (output.default) {
                    color = '#4caf50'; // Зеленый для дефолтных
                    width = 3;
                } else {
                    // Цвет из uistate
                    const nodeIndex = this.flowchartData.nodes.indexOf(fromNode);
                    if (this.uiStateData?.nodes?.[nodeIndex]?.outputs?.[outputIndex]?.color) {
                        const c = this.uiStateData.nodes[nodeIndex].outputs[outputIndex].color;
                        color = `rgba(${c[0]*255}, ${c[1]*255}, ${c[2]*255}, ${c[3]})`;
                    }
                }

                this.ctx.beginPath();
                this.ctx.strokeStyle = color;
                this.ctx.lineWidth = width;

                const cpDist = Math.abs(endPos.x - startPos.x) * 0.5;
                
                // Кривая безье
                this.ctx.moveTo(startPos.x, startPos.y);
                this.ctx.bezierCurveTo(
                    startPos.x + cpDist, startPos.y,
                    endPos.x - cpDist, endPos.y,
                    endPos.x, endPos.y
                );
                this.ctx.stroke();

                // Стрелка на конце
                const angle = Math.atan2(endPos.y - startPos.y, endPos.x - startPos.x); // Упрощенный угол
                // Более точный угол для конца кривой - вектор от P2 к P3
                // Но для простоты оставим прямую, так как P2 на одной высоте с P3 часто

                const arrowSize = isHovered ? 10 : 8;
                this.ctx.beginPath();
                this.ctx.moveTo(endPos.x, endPos.y);
                this.ctx.lineTo(
                    endPos.x - arrowSize * Math.cos(angle - Math.PI / 6),
                    endPos.y - arrowSize * Math.sin(angle - Math.PI / 6)
                );
                this.ctx.lineTo(
                    endPos.x - arrowSize * Math.cos(angle + Math.PI / 6),
                    endPos.y - arrowSize * Math.sin(angle + Math.PI / 6)
                );
                this.ctx.closePath();
                this.ctx.fillStyle = color;
                this.ctx.fill();
            }

            drawNodes() {
                if (!this.flowchartData.nodes) return;

                this.flowchartData.nodes.forEach((node, index) => {
                    this.drawNode(node, index);
                });
            }

            // --- ИСПРАВЛЕННЫЙ МЕТОД: Разделение цветов заголовка и обводки ---
            drawNode(node, index) {
                const pos = this.worldToScreen(node.x, node.y);
                const width = node.w * this.zoom;
                const height = node.h * this.zoom;
                const radius = 6 * this.zoom;
                const headerHeight = 30 * this.zoom;

                this.ctx.save();

                // 1. ОПРЕДЕЛЕНИЕ ЦВЕТОВ
                
                // Цвет заголовка: Фиксированный Construct Blue (#246aa2)
                // Если это стартовая нода - оставляем зеленый, как в Construct
                let headerColor = '#246aa2'; 
                if (node.s) headerColor = '#4caf50'; 

                // Цвет обводки: Берем из настроек (UI State) или черный по умолчанию
                let borderColor = '#000000';
                if (this.uiStateData?.nodes?.[index]?.node?.color) {
                    const c = this.uiStateData.nodes[index].node.color;
                    borderColor = `rgb(${c[0]*255}, ${c[1]*255}, ${c[2]*255})`;
                }

                // 2. Тело ноды (Фон)
                this.ctx.beginPath();
                this.ctx.roundRect(pos.x, pos.y, width, height, radius);
                this.ctx.fillStyle = '#2b2b2b';
                this.ctx.fill();

                // 3. Заголовок (Header Background)
                this.ctx.save();
                this.ctx.beginPath();
                this.ctx.roundRect(pos.x, pos.y, width, height, radius);
                this.ctx.clip(); // Обрезаем по скруглению
                
                this.ctx.fillStyle = headerColor; // Всегда синий (или зеленый для старта)
                this.ctx.fillRect(pos.x, pos.y, width, headerHeight);
                this.ctx.restore();

                // 4. ОБВОДКА (Border / Selection / Hover)
                this.ctx.beginPath();
                this.ctx.roundRect(pos.x, pos.y, width, height, radius);

                if (this.connectionStart && this.hoveredNode === node && this.connectionStart.node !== node) {
                    // Если тянем связь к этой ноде - подсветка цели
                    this.ctx.lineWidth = 3;
                    this.ctx.strokeStyle = '#ff9800'; 
                } else if (node === this.selectedNode) {
                    // Если нода выбрана - синяя жирная обводка
                    this.ctx.lineWidth = 3;
                    this.ctx.strokeStyle = '#0078d4';
                } else {
                    // ОБЫЧНОЕ СОСТОЯНИЕ: Используем пользовательский Border Color
                    // Если цвет черный - линия тонкая (1), если пользовательский - чуть толще (2)
                    this.ctx.lineWidth = (borderColor !== '#000000' && borderColor !== 'rgb(0, 0, 0)') ? 3 : 1;
                    this.ctx.strokeStyle = borderColor;
                }
                this.ctx.stroke();

                // 5. Текст заголовка
                this.ctx.fillStyle = '#ffffff';
                this.ctx.font = `bold ${Math.max(10, 13 * this.zoom)}px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif`;
                this.ctx.textBaseline = 'middle';
                const title = node.c || 'Node';
                this.ctx.fillText(title, pos.x + 10 * this.zoom, pos.y + (headerHeight / 2), width - 20 * this.zoom);

                // 6. Тэги
                if (node.t) {
                    this.ctx.fillStyle = '#888';
                    this.ctx.font = `italic ${Math.max(9, 11 * this.zoom)}px Arial`;
                    this.ctx.fillText(node.t, pos.x + 10 * this.zoom, pos.y + headerHeight + 12 * this.zoom);
                }

                // 7. Input Port (Вход слева)
                const inputY = pos.y + (height / 2);
                this.ctx.beginPath();
                this.ctx.arc(pos.x, inputY, 5 * this.zoom, -Math.PI / 2, Math.PI / 2, false);
                this.ctx.fillStyle = '#555';
                this.ctx.fill();

                // 8. Outputs (Выходы)
                if (node.outputs?.length > 0) {
                    const startY = headerHeight + (node.t ? 20 * this.zoom : 5 * this.zoom);
                    node.outputs.forEach((output, i) => {
                        this.drawOutput(node, output, i, pos, startY);
                    });
                }

                // Затемнение если нода выключена
                if (!node.e) {
                    this.ctx.fillStyle = 'rgba(0,0,0,0.5)';
                    this.ctx.beginPath();
                    this.ctx.roundRect(pos.x, pos.y, width, height, radius);
                    this.ctx.fill();
                }

                this.ctx.restore();
            }

            // --- НОВЫЙ МЕТОД: Отрисовка выхода (Output) ---
            drawOutput(node, output, index, nodePos, startY) {
                const rowHeight = 24 * this.zoom;
                const yOffset = startY + (index * rowHeight);
                const textY = nodePos.y + yOffset + (rowHeight / 2);
                
                // Текст выхода
                this.ctx.fillStyle = output.default ? '#8eff92' : '#cccccc'; // Светло-зеленый для дефолта
                this.ctx.font = `${Math.max(9, 12 * this.zoom)}px Arial`;
                const nameText = output.name + (output.value ? `: ${output.value}` : '');
                this.ctx.fillText(nameText, nodePos.x + 10 * this.zoom, textY);

                if (output.default) {
                    this.ctx.font = `bold ${Math.max(8, 10 * this.zoom)}px Arial`;
                    const metrics = this.ctx.measureText(nameText);
                    this.ctx.fillStyle = '#4caf50';
                    this.ctx.fillText('(Default)', nodePos.x + 15 * this.zoom + metrics.width, textY);
                }

                // Точка подключения (Connector Dot) справа
                const dotX = nodePos.x + (node.w * this.zoom);
                const dotY = nodePos.y + yOffset + (rowHeight / 2);
                
                // Рисуем кружок коннектора
                this.ctx.beginPath();
                this.ctx.arc(dotX, dotY, 5 * this.zoom, 0, Math.PI * 2);
                
                // Цвет коннектора зависит от того, подключен он или наведен
                if (this.hoveredOutput && this.hoveredOutput.output === output) {
                    this.ctx.fillStyle = '#ffffff'; // Подсветка при наведении
                } else if (output.cnSID) {
                    this.ctx.fillStyle = '#0078d4'; // Подключен
                } else {
                    this.ctx.fillStyle = '#444'; // Пустой
                }
                
                this.ctx.fill();
                this.ctx.strokeStyle = '#222';
                this.ctx.stroke();
            }
        }

        // Application
        const app = {
            editor: null,
            jsonData: null,
            uistateData: null,
            jsonFile: null,
            uistateFile: null
        };

        window.addEventListener('DOMContentLoaded', () => {
            // 1. Сначала убеждаемся, что редактор создан
            app.editor = new FlowchartEditor('canvas');

            // 2. Ссылки на меню
            const menus = {
                file: { btn: document.getElementById('fileMenuBtn'), drop: document.getElementById('fileDropdown') },
                edit: { btn: document.getElementById('editMenuBtn'), drop: document.getElementById('editDropdown') },
                view: { btn: document.getElementById('viewMenuBtn'), drop: document.getElementById('viewDropdown') }
            };

            function closeAllDropdowns() {
                Object.values(menus).forEach(m => {
                    if(m.drop) m.drop.style.display = 'none';
                    if(m.btn) m.btn.classList.remove('active');
                });
            }

            // 3. Обработчики кликов по пунктам меню
            Object.values(menus).forEach(m => {
                if (!m.btn) return;
                m.btn.addEventListener('click', (e) => {
                    if (m.btn.style.pointerEvents === 'none') return;
                    e.stopPropagation();
                    const isAlreadyOpen = m.drop.style.display === 'block';
                    closeAllDropdowns();
                    if (!isAlreadyOpen) {
                        m.drop.style.display = 'block';
                        m.btn.classList.add('active');
                    }
                });
            });

            document.addEventListener('click', () => closeAllDropdowns());

            // 4. Логика импорта файлов
            const fileInput = document.getElementById('jsonFiles');
            const importTrigger = document.getElementById('importTrigger');
            
            if (importTrigger) {
                importTrigger.addEventListener('click', () => fileInput.click());
            }

            if (fileInput) {
                fileInput.addEventListener('change', async (e) => {
                    const files = Array.from(e.target.files);
                    if (files.length === 0) return;

                    const jsonFile = files.find(f => f.name.endsWith('.json') && !f.name.endsWith('.uistate.json'));
                    if (!jsonFile) return alert("Ошибка: Выберите основной файл .json");

                    const baseName = jsonFile.name.replace('.json', '');
                    const expectedUistate = baseName + '.uistate.json';
                    const uistateFile = files.find(f => f.name === expectedUistate);

                    if (!uistateFile) return alert(`Ошибка: В выбранных файлах не найден сопутствующий файл состояния:\n${expectedUistate}`);

                    try {
                        app.jsonData = JSON.parse(await jsonFile.text());
                        app.uistateData = JSON.parse(await uistateFile.text());
                        
                        app.editor.loadFlowchart(app.jsonData, app.uistateData);
                        
                        // Активация меню Edit
                        menus.edit.btn.style.opacity = "1";
                        menus.edit.btn.style.pointerEvents = "auto";
                        
                        const statusEl = document.getElementById('status');
                        const fnameEl = document.getElementById('current-filename');
                        if(statusEl) statusEl.textContent = `Nodes: ${app.jsonData.nodes.length}`;
                        if(fnameEl) fnameEl.textContent = jsonFile.name.toUpperCase();
                        
                        fileInput.value = ''; // Сброс для возможности повторного выбора
                    } catch (err) {
                        alert("Ошибка чтения JSON: " + err.message);
                    }
                });
            }

            // 5. Кнопки Edit Mode и Reset View
            const toggleEditBtn = document.getElementById('toggleEditModeBtn');
            const cancelEditBtn = document.getElementById('menuCancelEditBtn');
            const menuSaveBtn = document.getElementById('menuSaveBtn');
            const menuSaveAsBtn = document.getElementById('menuSaveAsBtn');

            if (toggleEditBtn) {
                toggleEditBtn.addEventListener('click', () => {
                    if (!app.editor.editMode) {
                        app.editor.enterEditMode();
                        toggleEditBtn.textContent = "Exit & Save Changes";
                        if(cancelEditBtn) cancelEditBtn.style.display = "block";
                        
                        [menuSaveBtn, menuSaveAsBtn].forEach(btn => {
                            if(btn) {
                                btn.classList.remove('disabled');
                                btn.style.opacity = "1";
                            }
                        });
                    } else {
                        app.editor.saveFlowchart();
                        resetEditMenuUI();
                    }
                });
            }

            if (cancelEditBtn) {
                cancelEditBtn.addEventListener('click', () => {
                    app.editor.exitEditMode(false);
                    resetEditMenuUI();
                });
            }

            function resetEditMenuUI() {
                if(toggleEditBtn) toggleEditBtn.textContent = "Enter Edit Mode";
                if(cancelEditBtn) cancelEditBtn.style.display = "none";
                
                [menuSaveBtn, menuSaveAsBtn].forEach(btn => {
                    if(btn) {
                        btn.classList.add('disabled');
                        btn.style.opacity = "0.5";
                    }
                });
            }
            
            // Сохранение по меню
            if(menuSaveBtn) {
                menuSaveBtn.addEventListener('click', () => {
                    if(!menuSaveBtn.classList.contains('disabled')) app.editor.saveFlowchart();
                });
            }
            if(menuSaveAsBtn) {
                menuSaveAsBtn.addEventListener('click', () => {
                    if(!menuSaveAsBtn.classList.contains('disabled')) app.editor.saveFlowchartAs();
                });
            }

            const resetViewBtn = document.getElementById('menuResetViewBtn');
            if(resetViewBtn) {
                resetViewBtn.addEventListener('click', () => app.editor.resetView());
            }
            
            // 6. Кнопки тулбара (Delete, Add Output и т.д.)
            document.getElementById('addNodeBtn').addEventListener('click', () => {
                app.editor.addNodeAt(app.editor.canvas.width / 2, app.editor.canvas.height / 2);
            });
            document.getElementById('deleteNodeBtn').addEventListener('click', () => app.editor.deleteNode());
            document.getElementById('addOutputBtn').addEventListener('click', () => app.editor.addOutput());
            document.getElementById('enableNodeBtn').addEventListener('click', () => app.editor.toggleNodeEnabled());
            document.getElementById('setStartBtn').addEventListener('click', () => app.editor.setStartNode());
        });
    </script>
</body>
</html>