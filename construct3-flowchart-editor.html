<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Construct 3 Flowchart Editor</title>
    <style>
        :root {
            --bg-dark: #2b2b2b;
            --bg-panel: #1e1e1e;
            --bg-menu: #3c3c3c;
            --border: #3a3a3a;
            --accent: #0078d4;
            --accent-hover: #106ebe;
            --text-main: #e0e0e0;
            --text-dim: #888;
            --danger: #ff5555;
            --success: #4caf50;
            --warn: #ff9800;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; outline: none; }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-dark);
            color: var(--text-main);
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* --- UI COMPONENTS --- */
        .btn {
            padding: 8px 16px;
            background: var(--accent);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: background 0.2s;
        }
        .btn:hover:not(:disabled) { background: var(--accent-hover); }
        .btn:disabled { background: #555; cursor: not-allowed; opacity: 0.6; }
        .btn.small { padding: 4px 8px; font-size: 11px; }
        .btn.danger { background: var(--danger); }

        /* --- MENU BAR --- */
        #menu-bar {
            background: var(--bg-menu);
            height: 30px;
            display: flex;
            align-items: center;
            border-bottom: 1px solid #1e1e1e;
            user-select: none;
            z-index: 1000;
            font-size: 13px;
        }

        .menu-item {
            padding: 0 15px;
            height: 100%;
            display: flex;
            align-items: center;
            cursor: pointer;
            position: relative;
        }
        .menu-item:hover { background: #505050; }
        .menu-item.active { background: var(--accent) !important; }

        .dropdown {
            display: none;
            position: absolute;
            top: 30px; left: 0;
            background: #2d2d2d;
            border: 1px solid #454545;
            min-width: 200px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
            z-index: 1001;
        }
        .dropdown-item { padding: 8px 20px; cursor: pointer; color: var(--text-main); }
        .dropdown-item:hover:not(.disabled) { background: var(--accent); }
        .dropdown-item.disabled { opacity: 0.5; cursor: default; }
        .separator { height: 1px; background: #454545; margin: 4px 0; }

        /* --- FILENAME EDITING --- */
        #filename-display {
            cursor: pointer;
            border-bottom: 1px dashed transparent;
            transition: border-color 0.2s, color 0.2s;
            max-width: 200px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        #filename-display:hover {
            border-bottom-color: var(--accent);
            color: var(--accent-hover);
        }
        #filename-input {
            background: #222;
            color: var(--accent);
            border: 1px solid var(--accent);
            border-radius: 2px;
            padding: 2px 5px;
            font-size: 11px;
            font-weight: bold;
            font-family: inherit;
            outline: none;
            width: 150px;
        }

        /* --- SUBMENU --- */
        .dropdown-item {
            position: relative; /* Для позиционирования подменю */
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .dropdown-item .shortcut {
            color: #888;
            font-size: 11px;
            margin-left: 20px;
        }

        .dropdown-item .arrow {
            font-size: 10px;
            color: #aaa;
            margin-left: 10px;
        }

        /* Скрываем подменю по умолчанию */
        .submenu {
            display: none;
            position: absolute;
            left: 100%; /* Появляется справа от родителя */
            top: -5px;  /* Чуть выше для выравнивания */
            background: #2d2d2d;
            border: 1px solid #454545;
            min-width: 220px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
            z-index: 1002;
        }

        /* Показываем подменю при наведении на родительский пункт */
        .dropdown-item:hover > .submenu {
            display: block;
        }

        /* --- TOOLBAR --- */
        #toolbar {
            display: none;
            background: var(--bg-panel);
            padding: 8px;
            border-bottom: 1px solid var(--border);
            gap: 10px;
        }
        #toolbar.active { display: flex; }
        .toolbar-group { display: flex; gap: 5px; padding-right: 10px; border-right: 1px solid #555; }
        .toolbar-group:last-child { border: none; }

        /* --- MAIN AREA --- */
        #workspace {
            position: relative;
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        #canvas-container {
            flex: 1;
            position: relative;
            background: var(--bg-dark);
            overflow: hidden;
        }
        
        canvas { display: block; cursor: default; }
        canvas:active { cursor: default; } /* Управление переходит полностью к JS */
        canvas.editing { cursor: default; }

        /* --- PROPERTIES PANEL --- */
        #properties-panel {
            width: 350px;
            background: var(--bg-panel);
            border-left: 1px solid var(--border);
            overflow-y: auto;
            padding: 15px;
            display: none;
            z-index: 40;
        }
        #properties-panel.active { display: block; }

        .prop-group { margin-bottom: 20px; padding-bottom: 20px; border-bottom: 1px solid var(--border); }
        .prop-group h3 { margin-bottom: 10px; color: var(--accent); font-size: 14px; }
        .prop-row { margin-bottom: 10px; }
        .prop-row label { display: block; margin-bottom: 5px; font-size: 12px; color: var(--text-dim); }
        
        input[type="text"], input[type="number"], textarea, select {
            width: 100%; padding: 8px;
            background: #333; border: 1px solid #555;
            border-radius: 4px; color: var(--text-main);
            font-family: inherit;
        }
        textarea { min-height: 60px; resize: vertical; font-family: monospace; line-height: 1.4; }
        input[type="color"] { width: 100%; height: 35px; border: 1px solid #555; cursor: pointer; }

        /* --- OUTPUT ITEMS --- */
        .output-item {
            background: #2a2a2a; padding: 10px; margin-bottom: 10px;
            border-radius: 4px; border-left: 3px solid var(--accent);
        }
        .output-item.default { border-left-color: var(--success); }
        .output-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }

        /* --- OVERLAYS --- */
        #mode-indicator {
            position: absolute; top: 10px; left: 10px;
            background: rgba(30,30,30,0.9); padding: 6px 10px;
            border-radius: 4px; font-size: 12px; font-weight: bold; pointer-events: none;
        }
        .view-mode { color: var(--success); }
        .edit-mode { color: var(--warn); }

        .zoom-info {
            position: absolute; bottom: 10px; left: 10px;
            background: rgba(30,30,30,0.9); padding: 8px;
            border-radius: 4px; font-size: 12px; pointer-events: none;
        }

        #context-menu {
            position: fixed; background: #2a2a2a;
            border: 1px solid #555; border-radius: 4px;
            padding: 5px 0; z-index: 2000; display: none;
            min-width: 180px; box-shadow: 0 4px 12px rgba(0,0,0,0.5);
        }
        #context-menu.active { display: block; }
        .ctx-item { padding: 8px 15px; cursor: pointer; font-size: 13px; }
        .ctx-item:hover { background: #3a3a3a; }

        /* --- MODAL --- */
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 3000;
            display: none;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(2px);
        }
        .modal-overlay.active { display: flex; }
        
        .modal-box {
            background: var(--bg-panel);
            width: 90%; max-width: 600px;
            max-height: 85vh;
            border: 1px solid var(--border);
            border-radius: 6px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            display: flex; flex-direction: column;
            position: relative;
        }

        .modal-close {
            position: absolute; top: 10px; right: 15px;
            background: transparent; border: none;
            color: var(--text-dim); font-size: 24px; cursor: pointer;
            z-index: 10;
        }
        .modal-close:hover { color: var(--danger); }

        .modal-content {
            padding: 20px 30px;
            overflow-y: auto;
            color: var(--text-main);
            line-height: 1.6;
        }

        /* Help Content Styles */
        .modal-content h2 { color: var(--accent); border-bottom: 1px solid var(--border); padding-bottom: 10px; margin-bottom: 15px; }
        .modal-content h3 { color: var(--success); margin: 20px 0 10px 0; font-size: 1.1em; }
        .modal-content ul, .modal-content ol { padding-left: 20px; margin-bottom: 10px; }
        .modal-content li { margin-bottom: 5px; }
        
        .modal-content table { width: 100%; border-collapse: collapse; margin: 10px 0; font-size: 13px; }
        .modal-content th { text-align: left; border-bottom: 1px solid var(--border); color: var(--text-dim); padding: 5px; }
        .modal-content td { border-bottom: 1px solid #333; padding: 5px; }
        .modal-content kbd {
            background: #444; border-radius: 3px; padding: 2px 5px;
            font-family: monospace; border: 1px solid #555;
        }
        
        .modal-content pre {
            background: #222; padding: 10px; border-radius: 4px;
            overflow-x: auto; font-family: 'Consolas', monospace; font-size: 12px;
            border: 1px solid var(--border); color: #ccc;
        }
        .modal-content a { color: var(--accent); text-decoration: none; }
        .modal-content a:hover { text-decoration: underline; }
    </style>
</head>
<body>

    <!-- MENUS -->
    <div id="menu-bar">
        <div class="menu-item" data-menu="file">File
            <div class="dropdown" id="fileDropdown">
                <!-- Basic Operations (Stubs) -->
                <div id="btn-new" class="dropdown-item">New</div>
                <div id="btn-open" class="dropdown-item">Open...</div>
                
                <div class="separator"></div>
                
                <div id="btn-save-stub" class="dropdown-item">Save <span class="shortcut">Ctrl+S</span></div>
                <div id="btn-save-as-stub" class="dropdown-item">Save As... <span class="shortcut">Shift+Ctrl+S</span></div>

                <div class="separator"></div>

                <!-- IMPORT Submenu -->
                <div class="dropdown-item">
                    Import
                    <span class="arrow">▶</span>
                    <div class="submenu">
                        <div id="btn-import-c3" class="dropdown-item">Import (*.json & *.uistate.json)</div>
                        <div id="btn-import-mini" class="dropdown-item">Import MiniFlow (*.miniflow.json)</div>
                    </div>
                </div>

                <!-- EXPORT Submenu -->
                <div class="dropdown-item">
                    Export
                    <span class="arrow">▶</span>
                    <div class="submenu">
                        <div id="btn-export-c3" class="dropdown-item">Export (*.json & *.uistate.json)</div>
                        <div id="btn-export-mini" class="dropdown-item">Export MiniFlow (*.miniflow.json)</div>
                    </div>
                </div>
            </div>
        </div>
        <div class="menu-item" id="menu-edit-wrapper" style="opacity: 0.5; pointer-events: none;">Edit
            <div class="dropdown" id="editDropdown">
                <div id="btn-toggle-mode" class="dropdown-item">Enter Edit Mode</div>
                <div id="btn-cancel-edit" class="dropdown-item" style="color: var(--danger); display: none;">Cancel Editing</div>
            </div>
        </div>
        <div class="menu-item" data-menu="view">View
            <div class="dropdown" id="viewDropdown">
                <div id="btn-reset-view" class="dropdown-item">Reset View</div>
            </div>
        </div>
        <div class="menu-item" data-menu="help">Help
            <div class="dropdown" id="helpDropdown">
                <div class="dropdown-item" onclick="app.openHelp('getting-started')">Getting Started</div>
                <div class="dropdown-item" onclick="app.openHelp('controls')">Controls & Shortcuts</div>
                <div class="separator"></div>
                <div class="dropdown-item" onclick="app.openHelp('import-export')">Import / Export</div>
                <div class="dropdown-item" onclick="app.openHelp('formats')">Formats (MiniFlow & C3)</div>
                <div class="separator"></div>
                <div class="dropdown-item" onclick="app.openHelp('about')">About / Feedback</div>
            </div>
        </div>
        <div id="status-bar" style="margin-left: 20px; font-size: 11px; color: #aaa;">No flowchart loaded</div>
        <div id="filename-display" style="margin-left: auto; padding-right: 15px; color: var(--accent); font-size: 11px; font-weight: bold;"></div>
    </div>

    <!-- TOOLBAR -->
    <div id="toolbar">
        <div class="toolbar-group">
            <button class="btn small" id="tool-add-node">Add Node</button>
            <button class="btn small" id="tool-del-node" disabled>Delete Node</button>
        </div>
        <div class="toolbar-group">
            <button class="btn small" id="tool-add-out" disabled>Add Output</button>
            <button class="btn small" id="tool-del-out" disabled>Delete Output</button>
        </div>
        <div class="toolbar-group">
            <button class="btn small" id="tool-enable" disabled>Enable/Disable</button>
            <button class="btn small" id="tool-start" disabled>Set Start</button>
        </div>
    </div>

    <!-- WORKSPACE -->
    <div id="workspace">
        <div id="canvas-container">
            <canvas id="canvas"></canvas>
            <div id="mode-indicator" class="view-mode">VIEW MODE</div>
            <div class="zoom-info">
                <div>Zoom: <span id="zoom-level">100%</span></div>
                <div id="edit-hint" style="display:none; color: var(--warn); margin-top:4px;">Right-click for options</div>
            </div>
        </div>
        <div id="properties-panel">
            <div class="prop-group"><h3>No Selection</h3></div>
        </div>
    </div>

    <!-- HIDDEN & OVERLAYS -->
    <input type="file" id="file-input" accept=".json" multiple style="display: none;">
    <input type="file" id="file-input-mini" accept=".json" style="display: none;">
    <div id="context-menu"></div>
    <script src="help-content.js"></script>

    <!-- HELP MODAL -->
    <div id="help-modal" class="modal-overlay">
        <div class="modal-box">
            <button class="modal-close" onclick="document.getElementById('help-modal').classList.remove('active')">×</button>
            <div id="help-content" class="modal-content"></div>
        </div>
    </div>

    <script>
        // --- CONFIGURATION ---
        const CONFIG = {
            colors: {
                header: '#246aa2',
                headerStart: '#4caf50',
                outputNameDefault: '#4f99d4', 
                borderDefault: '#000000',
                selection: '#0078d4',
                connection: '#666666',
                connectionHover: '#ff9800',
                connectionDefault: '#4caf50',
                bgNode: '#2b2b2b',
                grid: '#3a3a3a',
                text: '#ffffff',
                textDim: '#888888',

                // Цвет рамки выделения
                marqueeStroke: '#0078d4',
                marqueeFill: 'rgba(0, 120, 212, 0.1)'
            },
            dims: {
                nodeW: 420,
                headerH: 32,      // Высота заголовка
                rowH: 33,         // Высота строки выхода (по замерам)
                footerH: 32,      // Высота подвала (для тегов)
                dotRadius: 8,
                borderRadius: 6,
                gridSize: 500,
                resizeMargin: 8
            },
            zoom: { min: 0.05, max: 2, stepIn: 1.1, stepOut: 0.9 },
            clickThreshold: 50
        };

        // --- MATH UTILS ---
        const Utils = {
            screenToWorld: (sx, sy, panX, panY, zoom) => ({ x: (sx - panX) / zoom, y: (sy - panY) / zoom }),
            worldToScreen: (wx, wy, panX, panY, zoom) => ({ x: wx * zoom + panX, y: wy * zoom + panY }),
            dist: (p1, p2) => Math.hypot(p1.x - p2.x, p1.y - p2.y),
            isPointInRect: (px, py, rx, ry, rw, rh) => px >= rx && px <= rx + rw && py >= ry && py <= ry + rh,
            isPointNearBezier: (px, py, p0, p3, threshold) => {
                const cpDist = Math.abs(p3.x - p0.x) * 0.5;
                const p1 = { x: p0.x + cpDist, y: p0.y };
                const p2 = { x: p3.x - cpDist, y: p3.y };
                const steps = 20;
                for (let i = 0; i <= steps; i++) {
                    const t = i / steps;
                    const it = 1 - t;
                    const x = it*it*it*p0.x + 3*it*it*t*p1.x + 3*it*t*t*p2.x + t*t*t*p3.x;
                    const y = it*it*it*p0.y + 3*it*it*t*p1.y + 3*it*t*t*p2.y + t*t*t*p3.y;
                    if (Math.hypot(px - x, py - y) < threshold) return true;
                }
                return false;
            },
            isRectOverlap: (r1, r2) => {
                return !(r2.left > r1.right || 
                        r2.right < r1.left || 
                        r2.top > r1.bottom || 
                        r2.bottom < r1.top);
            },
            uuid: () => Date.now() + Math.floor(Math.random() * 1000000)
        };

        class FlowchartEditor {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                
                this.data = { flowchart: null, ui: null, original: null };
                this.view = { zoom: 1, panX: 0, panY: 0 };
                
                this.state = {
                    mode: 'view',
                    dragging: false,
                    lastMouse: { x: 0, y: 0 },
                    
                    // Множественное выделение
                    selection: [], // Массив выделенных нод
                    selectionType: 'none', // 'none' | 'node' | 'connection'
                    selectedOutput: null, // Для редактирования свойств конкретного аутпута
                    
                    dragNode: null, // (Устарело, теперь используем selection для драга)
                    dragOffset: null, // Смещение курсора относительно якорной ноды
                    
                    connectionStart: null,
                    hover: { node: null, output: null, connection: null },
                    
                    resizing: false,
                    resizeTarget: null,
                    resizeDir: null,
                    
                    // Marquee (Рамка)
                    marqueeStart: null, // {x, y} в экранных координатах
                    marqueeCurrent: null,
                    isSpacePressed: false // Флаг для пробела
                };
                
                this.clipboard = null; 
                this.init();
            }

            init() {
                this.resize();
                window.addEventListener('resize', () => { this.resize(); this.render(); });
                this.bindEvents();
                this.bindFilenameEvents(); // <--- ДОБАВЛЕНО
            }

            resize() {
                const parent = this.canvas.parentElement;
                this.canvas.width = parent.clientWidth;
                this.canvas.height = parent.clientHeight;
            }

            bindEvents() {
                const c = this.canvas;
                
                // --- MOUSE INTERACTIONS ---
                c.addEventListener('mousedown', e => this.handleInput('down', e));
                c.addEventListener('mousemove', e => this.handleInput('move', e));
                c.addEventListener('mouseup', e => this.handleInput('up', e));
                c.addEventListener('mouseleave', () => { this.state.dragging = false; this.state.dragNode = null; });
                
                // --- ZOOM (TO CURSOR) ---
                c.addEventListener('wheel', e => {
                    if (e.ctrlKey) {
                        e.preventDefault();
                        
                        const rect = c.getBoundingClientRect();
                        const mx = e.clientX - rect.left;
                        const my = e.clientY - rect.top;

                        // 1. Координаты мира под курсором ДО зума
                        const worldX = (mx - this.view.panX) / this.view.zoom;
                        const worldY = (my - this.view.panY) / this.view.zoom;

                        // 2. Новый зум
                        const f = e.deltaY > 0 ? CONFIG.zoom.stepOut : CONFIG.zoom.stepIn;
                        const newZoom = Math.max(CONFIG.zoom.min, Math.min(CONFIG.zoom.max, this.view.zoom * f));

                        // 3. Новый Pan (чтобы точка мира осталась под курсором)
                        this.view.panX = mx - worldX * newZoom;
                        this.view.panY = my - worldY * newZoom;
                        this.view.zoom = newZoom;

                        document.getElementById('zoom-level').textContent = Math.round(this.view.zoom * 100) + '%';
                        this.render();
                    }
                });

                // --- CONTEXT MENU ---
                c.addEventListener('contextmenu', e => {
                    e.preventDefault();
                    if (this.state.mode === 'edit') this.showContextMenu(e);
                });

                document.addEventListener('click', () => document.getElementById('context-menu').classList.remove('active'));

                // --- SYSTEM CLIPBOARD CLEAR ---
                // Если пользователь копирует текст в инпуте, очищаем буфер нод, чтобы не вставить ноду вместо текста
                document.addEventListener('copy', (e) => {
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                        this.clipboard = null;
                    }
                });

               // Закрытие модального окна помощи при клике на затемнение
                document.getElementById('help-modal').addEventListener('mousedown', (e) => {
                    if (e.target.id === 'help-modal') {
                        e.target.classList.remove('active');
                    }
                });

                // --- KEYBOARD SHORTCUTS (DOWN) ---
                document.addEventListener('keydown', e => {
                    // 1. SPACE (PAN MODE)
                    if (e.code === 'Space' && !e.repeat && document.activeElement.tagName !== 'INPUT' && document.activeElement.tagName !== 'TEXTAREA') {
                        this.state.isSpacePressed = true;
                        this.canvas.style.cursor = 'grab';
                        return; // Прерываем, чтобы пробел не триггерил скролл страницы
                    }

                    // Проверка фокуса в полях ввода (чтобы Delete не удалял ноды при редактировании текста)
                    const targetTag = e.target.tagName;
                    const isInputActive = targetTag === 'INPUT' || targetTag === 'TEXTAREA' || e.target.isContentEditable;

                    // 2. DELETE, BACKSPACE
                    if (e.code === 'Delete' || e.code === 'Backspace') {
                        if (!isInputActive && this.state.mode === 'edit') {
                            if (e.code === 'Backspace') e.preventDefault();
                            this.deleteSelection(); // Вызов обновленного метода
                        }
                    }

                    // 3. ESCAPE
                    if (e.code === 'Escape') {
                        const modal = document.getElementById('help-modal');
                        if (modal.classList.contains('active')) {
                            modal.classList.remove('active');
                            return; // Прерываем, чтобы не снять выделение на холсте
                        }
                        
                        if (this.state.mode === 'edit') {
                            this.selectSingle(null);
                            this.state.selectionType = 'none';
                            this.render();
                        }
                    }

                    // Для остальных хоткеев (Ctrl+...) выходим, если активен ввод текста
                    if (isInputActive) return;

                    const isCtrl = e.ctrlKey || e.metaKey;

                    // 4. SAVE (Ctrl+S)
                    if (isCtrl && e.code === 'KeyS') {
                        e.preventDefault(); 
                        // Вызываем клик по кнопкам меню (так надежнее, чем вызывать глобальные функции)
                        if (e.shiftKey) {
                            document.getElementById('btn-save-as-stub').click();
                        } else {
                            // Если есть реальная кнопка Save (btn-save) или заглушка (btn-save-stub)
                            const btn = document.getElementById('btn-export-c3') || document.getElementById('btn-save-stub');
                            if(btn) btn.click();
                        }
                    }

                    // 5. COPY (Ctrl+C)
                    if (isCtrl && e.code === 'KeyC') {
                        if (this.state.mode === 'edit' && this.state.selection.length > 0) {
                            this.copyNode(); 
                        }
                    }

                    // 6. PASTE (Ctrl+V)
                    if (isCtrl && e.code === 'KeyV') {
                        if (this.state.mode === 'edit' && this.clipboard) {
                            // Вставляем в позицию курсора мыши (последнюю известную)
                            const rect = this.canvas.getBoundingClientRect();
                            const mx = this.state.lastMouse.x - rect.left;
                            const my = this.state.lastMouse.y - rect.top;
                            this.pasteNode(mx, my);
                        }
                    }
                });

                // --- KEYBOARD SHORTCUTS (UP) ---
                document.addEventListener('keyup', e => {
                    if (e.code === 'Space') {
                        this.state.isSpacePressed = false;
                        this.canvas.style.cursor = 'default';
                        if (this.state.dragging) this.state.dragging = false; 
                    }
                });
            }

            bindFilenameEvents() {
                const display = document.getElementById('filename-display');
                
                display.onclick = () => {
                    // Не разрешаем редактировать, если файл не загружен
                    if (!this.data.flowchart) return;
                    
                    // Если уже редактируем (есть инпут), выходим
                    if (display.querySelector('input')) return;

                    const currentName = this.data.flowchart.name || 'flowchart';
                    
                    // Создаем инпут
                    const input = document.createElement('input');
                    input.id = 'filename-input';
                    input.value = currentName;
                    
                    // Обработка сохранения
                    const save = () => {
                        let val = input.value.trim();
                        // Валидация: разрешаем буквы, цифры, _, -, пробелы. Остальное в _
                        val = val.replace(/[^a-zA-Z0-9_\-\sа-яА-Я]/g, '_');
                        
                        if (!val) val = 'flowchart'; // Дефолт, если пусто
                        
                        this.data.flowchart.name = val;
                        display.textContent = val;
                    };

                    // Blur = Сохранить
                    input.onblur = save;
                    
                    // Keydown
                    input.onkeydown = (e) => {
                        e.stopPropagation(); // Чтобы не срабатывали хоткеи редактора (Del, Space)
                        if (e.key === 'Enter') {
                            input.blur(); // Вызовет save
                        }
                        if (e.key === 'Escape') {
                            // Отмена - возвращаем старое имя без сохранения
                            display.textContent = currentName; 
                        }
                    };

                    display.textContent = '';
                    display.appendChild(input);
                    input.focus();
                    input.select();
                };
            }

            // --- INPUT HANDLING ---

            handleInput(type, e) {
                const rect = this.canvas.getBoundingClientRect();
                const mx = e.clientX - rect.left;
                const my = e.clientY - rect.top;

                // --- 1. MOUSE DOWN ---
                if (type === 'down') {
                    // A. PAN (СКМ или Пробел + ЛКМ)
                    // e.button === 1 (Колесо) ИЛИ (e.button === 0 (ЛКМ) И Пробел нажат)
                    if (e.button === 1 || (e.button === 0 && this.state.isSpacePressed)) {
                        this.state.dragging = true;
                        this.state.lastMouse = { x: e.clientX, y: e.clientY };
                        this.canvas.style.cursor = 'grabbing';
                        return; // Прерываем, чтобы не сработало выделение
                    }

                    // B. Контекстное меню (ПКМ) - просто прерываем, обработает событие 'contextmenu'
                    if (e.button === 2) {
                        return;
                    }

                    // C. ЛКМ (Основная логика)
                    if (e.button === 0) {
                        if (this.state.mode === 'edit') {
                            // 1. Приоритет на Output (Создание связи)
                            // Сначала ищем попадание в точку выхода (она важнее и может выходить за границы ноды)
                            let hitNode = this.hitTestNode(mx, my);
                            let hitOut = null;

                            for (let i = this.data.flowchart.nodes.length - 1; i >= 0; i--) {
                                const n = this.data.flowchart.nodes[i];
                                const res = this.hitTestOutput(n, mx, my);
                                if (res) {
                                    hitOut = res;
                                    hitNode = n; // Если попали в точку, обновляем контекст ноды
                                    break;
                                }
                            }

                            if (hitNode && hitOut) {
                                this.state.connectionStart = { node: hitNode, output: hitOut.output };
                                this.state.lastMouse = { x: e.clientX, y: e.clientY }; 
                                this.render();
                                return; 
                            }

                            // 2. Проверка клика по СВЯЗИ (Добавляем этот блок)
                            const hitConn = this.hitTestConnection(mx, my);
                            if (hitConn) {
                                const isShift = e.shiftKey;
                                
                                // Если ранее были выделены ноды, сбрасываем их
                                if (this.state.selectionType === 'node') {
                                    this.selectSingle(null);
                                }
                                
                                this.state.selectionType = 'connection';

                                // Логика мультивыделения для связей
                                if (isShift) {
                                    const index = this.state.selection.findIndex(x => x.output === hitConn.output);
                                    if (index >= 0) {
                                        this.state.selection.splice(index, 1);
                                    } else {
                                        this.state.selection.push(hitConn);
                                    }
                                } else {
                                    // Если кликнули без шифта по уже выделенной - не сбрасываем (для удобства), 
                                    // но если она не была выделена - выбираем только её.
                                    const alreadySelected = this.isSelectedConnection(hitConn.output);
                                    if (!alreadySelected) {
                                        this.state.selection = [hitConn];
                                    }
                                }
                                
                                this.updateUI(); // Обновит панель свойств (скроет свойства нод)
                                this.render();
                                return;
                            }

                            // 2.1. Ресайз
                            const resizeHit = this.hitTestResize(mx, my);
                            // Ресайзим, если кликнули по хендлу уже выделенной ноды, или если выделим её сейчас
                            if (resizeHit) {
                                // Если нода не была выделена - выделяем её одну
                                if (!this.isSelected(resizeHit.node)) {
                                    this.selectSingle(resizeHit.node);
                                }
                                
                                this.state.resizing = true;
                                this.state.resizeTarget = resizeHit.node;
                                this.state.resizeDir = resizeHit.dir;
                                this.state.lastMouse = { x: e.clientX, y: e.clientY };
                                return; 
                            }

                            // 3. Выделение / Драг Нод
                            if (hitNode) {
                                // Если были выделены связи, сбрасываем их полностью
                                if (this.state.selectionType === 'connection') {
                                    this.state.selection = [];
                                }
                                this.state.selectionType = 'node'; // Устанавливаем тип

                                const isShift = e.shiftKey;
                                const alreadySelected = this.isSelected(hitNode);

                                if (isShift) {
                                    this.toggleSelection(hitNode);
                                    // Драг возможен, если нода осталась выделенной
                                    this.state.dragNode = this.isSelected(hitNode) ? hitNode : null;
                                } else {
                                    if (!alreadySelected) {
                                        this.selectSingle(hitNode);
                                    }
                                    this.state.dragNode = hitNode;
                                }

                                const wp = Utils.screenToWorld(mx, my, this.view.panX, this.view.panY, this.view.zoom);
                                this.state.dragStartWorld = { x: wp.x, y: wp.y }; // Якорь для группы
                            } 
                            else {
                                // 5. Пустое место -> Сброс всего (если не пробел)
                                    if (!this.state.isSpacePressed) {
                                        if (!e.shiftKey) {
                                            this.selectSingle(null);
                                            this.state.selectionType = 'none'; // Сбрасываем тип
                                        }
                                    if (!e.shiftKey) this.selectSingle(null);

                                    this.state.marqueeStart = { x: mx, y: my };
                                    this.state.marqueeCurrent = { x: mx, y: my };
                                }
                            }
                            this.render();
                        }
                    }
                    this.state.lastMouse = { x: e.clientX, y: e.clientY };
                } 
                
                // --- 2. MOUSE MOVE ---
                else if (type === 'move') {
                    // А. Pan (если активен флаг dragging)
                    if (this.state.dragging) {
                        this.view.panX += e.clientX - this.state.lastMouse.x;
                        this.view.panY += e.clientY - this.state.lastMouse.y;
                        this.canvas.style.cursor = 'grabbing'; // <-- Это работает, оставляем
                        this.state.lastMouse = { x: e.clientX, y: e.clientY };
                        this.render();
                        return;
                    }

                    // 2. ДОБАВИТЬ: Логика для View Mode (когда не перетаскиваем)
                    if (this.state.mode === 'view') {
                        if (this.state.isSpacePressed) {
                            this.canvas.style.cursor = 'grab';
                        } else {
                            this.canvas.style.cursor = 'default';
                        }
                    }

                    // Если просто водим мышью с зажатым пробелом (без клика) - курсор grab
                    if (this.state.isSpacePressed && !this.state.dragging) {
                        this.canvas.style.cursor = 'grab';
                        this.state.lastMouse = { x: e.clientX, y: e.clientY };
                        return;
                    }

                    // Б. Ресайз
                    if (this.state.resizing && this.state.resizeTarget) {
                        const dx = (e.clientX - this.state.lastMouse.x) / this.view.zoom;
                        const dy = (e.clientY - this.state.lastMouse.y) / this.view.zoom;

                        this.state.selection.forEach(node => {
                            const minSize = this.getMinNodeSize(node);
                            if (this.state.resizeDir === 'w') {
                                const oldW = node.w;
                                const newW = Math.max(minSize.w, oldW + dx);
                                node.x += (newW - oldW) / 2;
                                node.w = newW;
                            } else if (this.state.resizeDir === 'h') {
                                const oldH = node.h;
                                const newH = Math.max(minSize.h, oldH + dy);
                                node.y += (newH - oldH) / 2;
                                node.h = newH;
                            }
                        });

                        this.canvas.style.cursor = this.state.resizeDir === 'w' ? 'ew-resize' : 'ns-resize';
                        this.state.lastMouse = { x: e.clientX, y: e.clientY };
                        this.render();
                        return;
                    }

                    // В. Тянем связь
                    if (this.state.connectionStart) {
                        const hitNode = this.hitTestNode(mx, my);
                        this.state.hover.node = (hitNode !== this.state.connectionStart.node) ? hitNode : null;
                        this.state.lastMouse = { x: e.clientX, y: e.clientY };
                        this.render();
                        return;
                    }

                    // Г. Marquee
                    if (this.state.marqueeStart) {
                        this.state.marqueeCurrent = { x: mx, y: my };
                        this.render();
                        return;
                    }

                    // Д. Drag Nodes
                    if (this.state.dragNode) {
                        const wp = Utils.screenToWorld(mx, my, this.view.panX, this.view.panY, this.view.zoom);
                        const dx = wp.x - this.state.dragStartWorld.x;
                        const dy = wp.y - this.state.dragStartWorld.y;

                        this.state.selection.forEach(node => {
                            node.x += dx;
                            node.y += dy;
                        });

                        this.state.dragStartWorld = { x: wp.x, y: wp.y };
                        this.canvas.style.cursor = 'grabbing';
                        this.state.lastMouse = { x: e.clientX, y: e.clientY };
                        this.render();
                        return;
                    }

                    // Е. Hover эффекты (без кнопок)
                    if (this.state.mode === 'edit') {
                        // Сохраняем предыдущее состояние, чтобы понять, нужна ли перерисовка
                        const prevHoverOut = this.state.hover.output;
                        const prevHoverNode = this.state.hover.node;

                        let hitNode = this.hitTestNode(mx, my);
                        let hitOut = null;

                        // Цикл поиска hitOut (из предыдущего фикса)
                        for (let i = this.data.flowchart.nodes.length - 1; i >= 0; i--) {
                            const n = this.data.flowchart.nodes[i];
                            const res = this.hitTestOutput(n, mx, my);
                            if (res) {
                                hitOut = res;
                                hitNode = n;
                                break;
                            }
                        }
                        
                        this.state.hover.node = hitNode;
                        this.state.hover.output = hitOut; // hitOut уже найден выше в цикле
                        this.state.hover.connection = (!hitNode) ? this.hitTestConnection(mx, my) : null;

                        // ПРИОРИТЕТЫ КУРСОРОВ
                        if (hitOut) {
                            // 1. Наведение на точку выхода
                            this.canvas.style.cursor = 'pointer'; // Как вы просили
                        } else if (this.state.hover.connection) {
                            // 2. Наведение на связь
                            this.canvas.style.cursor = 'pointer'; // Как вы просили
                        } else if (hitNode) {
                            // 3. Наведение на ноду
                            if (this.isSelected(hitNode)) {
                                const resizeHit = this.hitTestResize(mx, my);
                                this.canvas.style.cursor = resizeHit ? (resizeHit.dir === 'w' ? 'ew-resize' : 'ns-resize') : 'grab';
                            } else {
                                this.canvas.style.cursor = 'grab';
                            }
                        } else {
                            // 4. Пустое место
                            this.canvas.style.cursor = 'default';
                        }
                        // Если объект под курсором изменился, перерисовываем холст
                        const outputChanged = (prevHoverOut?.output !== hitOut?.output);
                        const nodeChanged = (prevHoverNode !== hitNode);
                        
                        if (outputChanged || nodeChanged) {
                            this.render();
                        }
                    }
                    this.state.lastMouse = { x: e.clientX, y: e.clientY };
                } 
                
                // --- 3. MOUSE UP ---
                else if (type === 'up') {
                    if (this.state.marqueeStart) {
                        this.applyMarqueeSelection(e.shiftKey);
                        this.state.marqueeStart = null;
                        this.state.marqueeCurrent = null;
                        this.render();
                    }

                    if (this.state.resizing) {
                        this.state.resizing = false;
                        this.state.resizeTarget = null;
                        this.canvas.style.cursor = 'default';
                    }

                    if (this.state.connectionStart) {
                        let target = this.state.hover.node || this.findClosestNode(mx, my);
                        if (target && target !== this.state.connectionStart.node) {
                            this.connect(this.state.connectionStart.node, this.state.connectionStart.output, target);
                        }
                        this.state.connectionStart = null;
                        this.render();
                    }
                    
                    this.state.dragging = false;
                    this.state.dragNode = null;

                    // Сбрасываем курсор после завершения любого действия (особенно Pan колесиком)
                    if (this.state.mode === 'view') {
                        // Если пробел все еще держим - возвращаем grab, иначе - стрелка
                        this.canvas.style.cursor = this.state.isSpacePressed ? 'grab' : 'default';
                    } else {
                        // В Edit mode сбрасываем на дефолт (или можно добавить логику hover, но default безопаснее)
                        this.canvas.style.cursor = 'default';
                    }
                }
            }

           applyMarqueeSelection(isShift) {
                if (!this.state.marqueeStart || !this.state.marqueeCurrent) return;

                // 1. Нормализуем координаты рамки (экранные -> экранные Rect)
                const x1 = Math.min(this.state.marqueeStart.x, this.state.marqueeCurrent.x);
                const y1 = Math.min(this.state.marqueeStart.y, this.state.marqueeCurrent.y);
                const x2 = Math.max(this.state.marqueeStart.x, this.state.marqueeCurrent.x);
                const y2 = Math.max(this.state.marqueeStart.y, this.state.marqueeCurrent.y);
                const marqueeRect = { left: x1, top: y1, right: x2, bottom: y2 };

                // Игнорируем микро-сдвиги
                if (Math.abs(x2 - x1) < 5 && Math.abs(y2 - y1) < 5) return;

                const candidateNodes = [];
                const candidateConns = [];

                // 2. Поиск НОД в рамке
                this.data.flowchart.nodes.forEach(node => {
                    const outputsCount = node.outputs ? node.outputs.length : 0;
                    const contentH = CONFIG.dims.headerH + (outputsCount * CONFIG.dims.rowH) + CONFIG.dims.footerH + 10;
                    const actualH = Math.max(node.h, contentH);
                    
                    const tl = Utils.worldToScreen(node.x - node.w/2, node.y - actualH/2, this.view.panX, this.view.panY, this.view.zoom);
                    const br = Utils.worldToScreen(node.x + node.w/2, node.y + actualH/2, this.view.panX, this.view.panY, this.view.zoom);
                    
                    const nodeRect = { left: tl.x, top: tl.y, right: br.x, bottom: br.y };

                    if (Utils.isRectOverlap(marqueeRect, nodeRect)) {
                        candidateNodes.push(node);
                    }
                });

                // 3. Поиск СВЯЗЕЙ в рамке (только если не нашли ноды, либо ищем всё для проверки приоритета)
                // Для UX лучше: если зацепили ноду, связи игнорируем. Но посчитаем всё.
                this.data.flowchart.nodes.forEach(node => {
                    if (!node.outputs) return;
                    node.outputs.forEach((out, idx) => {
                        if (out.cnSID && out.enable) {
                            const target = this.data.flowchart.nodes.find(n => n.sid === out.cnSID);
                            if (target) {
                                const pStart = this.getOutputPos(node, idx);
                                const pEnd = this.getNodeInputPos(target);

                                // Вычисляем Bounding Box кривой Безье (упрощенно по контрольным точкам)
                                // Безье: Start -> CP1 -> CP2 -> End
                                const cpDist = Math.abs(pEnd.x - pStart.x) * 0.5;
                                const cp1 = { x: pStart.x + cpDist, y: pStart.y };
                                const cp2 = { x: pEnd.x - cpDist, y: pEnd.y };

                                const minX = Math.min(pStart.x, pEnd.x, cp1.x, cp2.x);
                                const maxX = Math.max(pStart.x, pEnd.x, cp1.x, cp2.x);
                                const minY = Math.min(pStart.y, pEnd.y, cp1.y, cp2.y);
                                const maxY = Math.max(pStart.y, pEnd.y, cp1.y, cp2.y);

                                // Добавляем небольшой padding (толщина линии)
                                const connRect = { left: minX - 5, top: minY - 5, right: maxX + 5, bottom: maxY + 5 };

                                if (Utils.isRectOverlap(marqueeRect, connRect)) {
                                    candidateConns.push({ output: out, sourceNode: node });
                                }
                            }
                        }
                    });
                });

                // 4. Логика разрешения конфликтов (PRIORITY: NODES > CONNECTIONS)
                
                // Если найдены НОДЫ
                if (candidateNodes.length > 0) {
                    // Если текущий режим - связи, сбрасываем всё
                    if (this.state.selectionType === 'connection') {
                        this.state.selection = [];
                        this.state.selectionType = 'node';
                    } else if (this.state.selectionType === 'node' && !isShift) {
                        // Если режим нод, но не шифт - сбрасываем старое выделение
                        this.state.selection = [];
                    }
                    this.state.selectionType = 'node';

                    // Добавляем кандидатов
                    candidateNodes.forEach(n => {
                        if (!this.isSelected(n)) this.state.selection.push(n);
                    });
                } 
                // Если нод нет, но есть СВЯЗИ
                else if (candidateConns.length > 0) {
                    // Если текущий режим - ноды, сбрасываем всё (даже если Shift)
                    // Т.к. нельзя смешивать типы
                    if (this.state.selectionType === 'node') {
                        this.state.selection = [];
                        this.state.selectionType = 'connection';
                    } else if (this.state.selectionType === 'connection' && !isShift) {
                         this.state.selection = [];
                    } else if (this.state.selectionType === 'none') {
                        this.state.selectionType = 'connection';
                    }

                    // Добавляем кандидатов
                    candidateConns.forEach(cand => {
                        // Проверка на уникальность для связей
                        const exists = this.state.selection.some(s => s.output === cand.output);
                        if (!exists) this.state.selection.push(cand);
                    });
                }
                // Если ничего не нашли и не зажат Shift -> сброс
                else if (!isShift) {
                    this.state.selection = [];
                    this.state.selectionType = 'none';
                }

                this.updateUI();
            }

            // --- HIT TESTING ---

            hitTestNode(mx, my) {
                if (!this.data.flowchart) return null;
                const wp = Utils.screenToWorld(mx, my, this.view.panX, this.view.panY, this.view.zoom);
                
                for (let i = this.data.flowchart.nodes.length - 1; i >= 0; i--) {
                    const n = this.data.flowchart.nodes[i];
                    
                    const outputsCount = n.outputs ? n.outputs.length : 0;
                    const contentH = CONFIG.dims.headerH + (outputsCount * CONFIG.dims.rowH) + CONFIG.dims.footerH + 10;
                    const actualH = Math.max(n.h, contentH);

                    const left = n.x - (n.w / 2);
                    const top = n.y - (actualH / 2);
                    
                    if (Utils.isPointInRect(wp.x, wp.y, left, top, n.w, actualH)) return n;
                }
                return null;
            }

            // Проверка попадания в границы ноды для ресайза
            // Возвращает объект { node, dir: 'w' | 'h' } или null
            hitTestResize(mx, my) {
                if (!this.data.flowchart) return null;
                const margin = CONFIG.dims.resizeMargin;
                
                for (let i = this.data.flowchart.nodes.length - 1; i >= 0; i--) {
                    const n = this.data.flowchart.nodes[i];
                    
                    const outputsCount = n.outputs ? n.outputs.length : 0;
                    const contentH = CONFIG.dims.headerH + (outputsCount * CONFIG.dims.rowH) + CONFIG.dims.footerH + 10;
                    
                    // Используем реальную высоту (юзерскую или контентную)
                    const actualH = Math.max(n.h, contentH);
                    
                    const topLeftX = n.x - (n.w / 2);
                    const topLeftY = n.y - (actualH / 2);
                    
                    const screenPos = Utils.worldToScreen(topLeftX, topLeftY, this.view.panX, this.view.panY, this.view.zoom);
                    const screenW = n.w * this.view.zoom;
                    const screenH = actualH * this.view.zoom;

                    const left = screenPos.x;
                    const right = screenPos.x + screenW;
                    const top = screenPos.y;
                    const bottom = screenPos.y + screenH;

                    if (my >= top && my <= bottom && mx >= right - margin && mx <= right + margin) return { node: n, dir: 'w' };
                    if (mx >= left && mx <= right && my >= bottom - margin && my <= bottom + margin) return { node: n, dir: 'h' };
                }
                return null;
            }

            hitTestOutput(node, mx, my) {
                if (!node.outputs) return null;
                
                const outputsCount = node.outputs.length;
                const contentH = CONFIG.dims.headerH + (outputsCount * CONFIG.dims.rowH) + CONFIG.dims.footerH + 10;
                const actualH = Math.max(node.h, contentH);
                
                const topLeftX = node.x - (node.w / 2);
                const topLeftY = node.y - (actualH / 2);
                
                const sp = Utils.worldToScreen(topLeftX, topLeftY, this.view.panX, this.view.panY, this.view.zoom);
                
                const startY = sp.y + CONFIG.dims.headerH * this.view.zoom + (5 * this.view.zoom);
                const dotX = sp.x + node.w * this.view.zoom;
                const r = 25 * this.view.zoom; 

                for (let i = 0; i < node.outputs.length; i++) {
                    const dotY = startY + (i * CONFIG.dims.rowH * this.view.zoom) + (CONFIG.dims.rowH * this.view.zoom / 2);
                    if (Math.hypot(mx - dotX, my - dotY) < r) return { output: node.outputs[i], index: i };
                }
                return null;
            }

            hitTestConnection(mx, my) {
                if (!this.data.flowchart) return null;
                for (const node of this.data.flowchart.nodes) {
                    if (!node.outputs) continue;
                    for (let i = 0; i < node.outputs.length; i++) {
                        const out = node.outputs[i];
                        if (out.cnSID && out.enable) {
                            const target = this.data.flowchart.nodes.find(n => n.sid === out.cnSID);
                            if (target) {
                                const pStart = this.getOutputPos(node, i);
                                const pEnd = this.getNodeInputPos(target);
                                
                                // Возвращаем и output, и исходную ноду (sourceNode)
                                if (Utils.isPointNearBezier(mx, my, pStart, pEnd, 5)) {
                                    return { output: out, sourceNode: node };
                                }
                            }
                        }
                    }
                }
                return null;
            }

            findClosestNode(mx, my) {
                const wp = Utils.screenToWorld(mx, my, this.view.panX, this.view.panY, this.view.zoom);
                let closest = null, minDist = CONFIG.clickThreshold;
                this.data.flowchart.nodes.forEach(n => {
                    const d = Utils.dist(wp, { x: n.x + n.w/2, y: n.y + n.h/2 });
                    if (d < minDist) { minDist = d; closest = n; }
                });
                return closest;
            }

            getOutputPos(node, idx) {
                const hh = CONFIG.dims.headerH;
                const rh = CONFIG.dims.rowH;
                const fh = CONFIG.dims.footerH;
                const outputsCount = node.outputs ? node.outputs.length : 0;
                
                const contentH = hh + (outputsCount * rh) + fh + 10;
                const actualH = Math.max(node.h, contentH);
                
                const topLeftX = node.x - (node.w / 2);
                const topLeftY = node.y - (actualH / 2);

                const topPadding = 5; 
                const worldY = topLeftY + hh + topPadding + (idx * rh) + (rh / 2);
                const worldX = topLeftX + node.w;

                return Utils.worldToScreen(worldX, worldY, this.view.panX, this.view.panY, this.view.zoom);
            }

            getNodeInputPos(node) {
                // node.y - это уже центр по вертикали!
                const worldY = node.y;
                
                // Левая грань = центр - половина ширины
                const worldX = node.x - (node.w / 2);

                return Utils.worldToScreen(worldX, worldY, this.view.panX, this.view.panY, this.view.zoom);
            }

            // --- SELECTION HELPERS ---

            // Полная замена выделения
            selectSingle(node) {
                this.state.selection = node ? [node] : [];
                this.updateUI();
            }

            // Добавление в выборку
            addToSelection(node) {
                if (!this.state.selection.includes(node)) {
                    this.state.selection.push(node);
                    this.updateUI();
                }
            }

            // Удаление из выборки
            removeFromSelection(node) {
                this.state.selection = this.state.selection.filter(n => n !== node);
                this.updateUI();
            }

            // Переключение (Toggle)
            toggleSelection(node) {
                if (this.state.selection.includes(node)) {
                    this.removeFromSelection(node);
                } else {
                    this.addToSelection(node);
                }
            }

            // Проверка, выделена ли нода
            isSelected(node) {
                return this.state.selection.includes(node);
            }

            // Проверка, выделена ли конкретная связь (по объекту output)
            isSelectedConnection(output) {
                if (this.state.selectionType !== 'connection') return false;
                return this.state.selection.some(item => item.output === output);
            }

            // Обновление панели свойств (упрощенно)
            updateUI() {
                const count = this.state.selection.length;
                const panel = document.getElementById('properties-panel');
                
                // Кнопки тулбара
                const btnDel = document.getElementById('tool-del-node');
                const btnAddOut = document.getElementById('tool-add-out');
                const btnEnable = document.getElementById('tool-enable');
                const btnStart = document.getElementById('tool-start');
                const btnDelOut = document.getElementById('tool-del-out');

                // 1. Ничего не выделено
                if (count === 0) {
                    panel.innerHTML = '<div class="prop-group"><h3>No Selection</h3></div>';
                    btnDel.disabled = true;
                    btnAddOut.disabled = true;
                    btnEnable.disabled = true;
                    btnStart.disabled = true;
                    btnDelOut.disabled = true;
                } 
                // 2. Выделены СВЯЗИ
                else if (this.state.selectionType === 'connection') {
                    const title = count === 1 ? 'Connection Selected' : `Selection (${count} connections)`;
                    panel.innerHTML = `<div class="prop-group"><h3>${title}</h3><p style="color:#aaa">Press Delete to remove connection.</p></div>`;
                    
                    btnDel.disabled = false;
                    btnAddOut.disabled = true;
                    btnEnable.disabled = true;
                    btnStart.disabled = true;
                    btnDelOut.disabled = true;
                } 
                // 3. Выделены НОДЫ
                else if (this.state.selectionType === 'node') {
                    btnDel.disabled = false;

                    if (count === 1) {
                        // Одиночное выделение
                        this.generateProperties(this.state.selection[0]);
                        
                        // Активируем кнопки действий для одной ноды
                        btnAddOut.disabled = false;
                        btnEnable.disabled = false; 
                        btnStart.disabled = false;
                    } else {
                        // Множественное выделение
                        panel.innerHTML = `<div class="prop-group"><h3>Multiple Selection (${count} items)</h3><p style="color:#aaa">Properties editing is disabled for multiple items.</p></div>`;
                        
                        // Отключаем специфичные действия для группы (пока не реализовано массовое редактирование)
                        btnAddOut.disabled = true;
                        btnEnable.disabled = true; 
                        btnStart.disabled = true;
                        btnDelOut.disabled = true;
                    }
                }
            }

            // --- LOGIC & CRUD ---

            connect(source, output, target) {
                output.cnSID = target.sid;
                // Note: Full connectivity (pnSIDs etc) is rebuilt on save to ensure consistency
            }

            select(node) {
                this.state.selection.node = node;
                // Update UI
                const panel = document.getElementById('properties-panel');
                if (node) this.generateProperties(node);
                else panel.innerHTML = '<div class="prop-group"><h3>No Selection</h3></div>';
                
                // Update Toolbar
                document.getElementById('tool-del-node').disabled = !node;
                document.getElementById('tool-add-out').disabled = !node;
                document.getElementById('tool-del-out').disabled = true; 
                document.getElementById('tool-enable').disabled = !node;
                document.getElementById('tool-start').disabled = !node;
            }

            addNode(screenX, screenY) {
                const wp = Utils.screenToWorld(screenX, screenY, this.view.panX, this.view.panY, this.view.zoom);
                
                // Рассчитываем высоту для 1 выхода (дефолт)
                const defaultOutputsCount = 1;
                const calcH = CONFIG.dims.headerH + (defaultOutputsCount * CONFIG.dims.rowH) + CONFIG.dims.footerH + 10;

                const newNode = {
                    sid: Utils.uuid(), 
                    pnSIDs: [], poSIDs: [], nodeSIDs: [],
                    x: wp.x - 210, 
                    y: wp.y - (calcH / 2), 
                    w: 420, 
                    h: calcH, // <--- Правильная начальная высота
                    t: "", s: false, e: true, c: "New Node",
                    pi: 0, ty: "dictionary", pr: false, prfsid: null, prfnsid: null,
                    outputs: [{ 
                        sid: Utils.uuid()+1, 
                        cnSID: null, 
                        name: "Option 1", 
                        value: "", 
                        enable: true, 
                        default: false 
                    }]
                };
                
                this.data.flowchart.nodes.push(newNode);

                // 2. UI State Structure (matches backup)
                this.data.ui.nodes.push({ 
                    node: { 
                        propertiesBar: {}, 
                        nodeTable: {}, 
                        color: [0.8, 0.8, 0.8, 1] 
                    }, 
                    outputs: [{ 
                        color: [0, 0, 0, 1], 
                        linkMode: "line", 
                        propertiesBar: {} 
                    }] 
                });
                
                this.select(newNode);
                this.render();
            }

            // Удаление всех выделенных нод
            deleteSelection() {
                if (this.state.selection.length === 0) return;

                // УДАЛЕНИЕ НОД
                if (this.state.selectionType === 'node') {
                    const nodesToDelete = [...this.state.selection];
                    nodesToDelete.forEach(node => this._deleteNodeInternal(node));
                    this.selectSingle(null);
                    this.state.selectionType = 'none';
                } 
                // УДАЛЕНИЕ СВЯЗЕЙ
                else if (this.state.selectionType === 'connection') {
                    // selection содержит объекты { output, sourceNode }
                    this.state.selection.forEach(item => {
                        if (item.output) {
                            item.output.cnSID = null; // Разрываем связь
                        }
                    });
                    this.state.selection = [];
                    this.state.selectionType = 'none';
                }

                this.render();
            }

            // Внутренний метод удаления одной ноды (без ререндера и сброса выделения)
            _deleteNodeInternal(node) {
                const index = this.data.flowchart.nodes.indexOf(node);
                if (index > -1) {
                    // 1. Удаляем связи
                    this.data.flowchart.nodes.forEach(n => {
                        // Очищаем входящие ссылки (cnSID) в аутпутах других нод
                        if (n.outputs) {
                            n.outputs.forEach(o => { 
                                if (o.cnSID === node.sid) o.cnSID = null; 
                            });
                        }
                        // Очищаем списки pnSIDs/nodeSIDs (для чистоты, хотя rebuildConnectivity всё поправит)
                        if (n.pnSIDs) n.pnSIDs = n.pnSIDs.filter(sid => sid !== node.sid);
                        if (n.nodeSIDs) n.nodeSIDs = n.nodeSIDs.filter(sid => sid !== node.sid);
                    });

                    // 2. Удаляем саму ноду из данных и UI
                    this.data.flowchart.nodes.splice(index, 1);
                    this.data.ui.nodes.splice(index, 1);
                }
            }

            getMinNodeSize(node) {
                // Минимальная ширина (заголовок должен влезать хотя бы частично)
                const minW = 200; 

                // Минимальная высота: Шапка + Выходы + Футер + Отступы
                const hh = CONFIG.dims.headerH;
                const rh = CONFIG.dims.rowH;
                const fh = CONFIG.dims.footerH;
                const outputsCount = node.outputs ? node.outputs.length : 0;
                
                // 10px padding
                const minH = hh + (outputsCount * rh) + fh + 10;

                return { w: minW, h: minH };
            }

            // --- CLIPBOARD OPERATIONS ---

            copyNode(node) {
                // Если передана конкретная нода (через контекстное меню), копируем её
                // Если нет аргумента (Ctrl+C), копируем всё выделение
                let nodesToCopy = [];
                if (node) {
                    nodesToCopy = [node];
                } else {
                    nodesToCopy = this.state.selection;
                }

                if (nodesToCopy.length === 0) return;

                // Сериализуем массив
                const clipboardPayload = nodesToCopy.map(n => {
                    const idx = this.data.flowchart.nodes.indexOf(n);
                    return {
                        logic: JSON.parse(JSON.stringify(n)),
                        ui: JSON.parse(JSON.stringify(this.data.ui.nodes[idx]))
                    };
                });
                
                // Вычисляем центр bounding box скопированной группы (для корректной вставки)
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                clipboardPayload.forEach(item => {
                    minX = Math.min(minX, item.logic.x);
                    minY = Math.min(minY, item.logic.y);
                    maxX = Math.max(maxX, item.logic.x);
                    maxY = Math.max(maxY, item.logic.y);
                });

                this.clipboard = {
                    items: clipboardPayload,
                    center: {
                        x: (minX + maxX) / 2,
                        y: (minY + maxY) / 2
                    }
                };
            }

            pasteNode(screenX, screenY) {
                if (!this.clipboard || !this.clipboard.items) return;

                const wp = Utils.screenToWorld(screenX, screenY, this.view.panX, this.view.panY, this.view.zoom);
                
                // Снимаем текущее выделение
                this.selectSingle(null);

                this.clipboard.items.forEach(item => {
                    // 1. Логика
                    const newNode = JSON.parse(JSON.stringify(item.logic));
                    newNode.sid = Utils.uuid();
                    
                    // Расчет позиции: Новая позиция = Курсор + (Старая позиция - Старый центр группы)
                    newNode.x = wp.x + (item.logic.x - this.clipboard.center.x);
                    newNode.y = wp.y + (item.logic.y - this.clipboard.center.y);
                    
                    newNode.pnSIDs = []; newNode.poSIDs = []; newNode.nodeSIDs = [];
                    if (newNode.outputs) {
                        newNode.outputs.forEach(out => { out.sid = Utils.uuid(); out.cnSID = null; });
                    }

                    // 2. UI
                    const newUiNode = JSON.parse(JSON.stringify(item.ui));
                    
                    this.data.flowchart.nodes.push(newNode);
                    this.data.ui.nodes.push(newUiNode);
                    
                    // Добавляем в выделение
                    this.addToSelection(newNode);
                });

                this.render();
            }

            // --- RENDERING ---

            render() {
                if (!this.data.flowchart) return;
                const ctx = this.ctx;
                ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                // 1. СЕТКА И ОСИ
                this.drawGrid();
                
                // 2. СВЯЗИ
                this.data.flowchart.nodes.forEach((node, nIdx) => {
                    node.outputs?.forEach((out, oIdx) => {
                        if (out.cnSID && out.enable) {
                            const target = this.data.flowchart.nodes.find(n => n.sid === out.cnSID);
                            if (target) this.drawConnection(node, nIdx, out, oIdx, target);
                        }
                    });
                });

                // 2.1 Активная связь (drag)
                 if (this.state.connectionStart) {
                    const start = this.getOutputPos(this.state.connectionStart.node, 
                        this.state.connectionStart.node.outputs.indexOf(this.state.connectionStart.output));
                    
                    // Координаты мыши
                    const rect = this.canvas.getBoundingClientRect();
                    let end = { 
                        x: this.state.lastMouse.x - rect.left, 
                        y: this.state.lastMouse.y - rect.top 
                    };
                    
                    if (this.state.hover.node) {
                        // ИЗМЕНЕНИЕ: Магнитизм к правильному центру визуальной ноды
                        end = this.getNodeInputPos(this.state.hover.node);
                    }

                    ctx.beginPath();
                    ctx.strokeStyle = '#fff';
                    ctx.setLineDash([5, 5]);
                    ctx.moveTo(start.x, start.y);
                    ctx.lineTo(end.x, end.y);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }

                // 3. НОДЫ
                this.data.flowchart.nodes.forEach((node, i) => this.drawNode(node, i));

                 // 4. MARQUEE SELECTION
                if (this.state.marqueeStart && this.state.marqueeCurrent) {
                    const x = Math.min(this.state.marqueeStart.x, this.state.marqueeCurrent.x);
                    const y = Math.min(this.state.marqueeStart.y, this.state.marqueeCurrent.y);
                    const w = Math.abs(this.state.marqueeCurrent.x - this.state.marqueeStart.x);
                    const h = Math.abs(this.state.marqueeCurrent.y - this.state.marqueeStart.y);

                    ctx.save();
                    ctx.strokeStyle = CONFIG.colors.marqueeStroke;
                    ctx.fillStyle = CONFIG.colors.marqueeFill;
                    ctx.lineWidth = 1;
                    ctx.setLineDash([4, 4]);
                    ctx.fillRect(x, y, w, h);
                    ctx.strokeRect(x, y, w, h);
                    ctx.restore();
                }
            }

            drawGrid() {
                const ctx = this.ctx;
                const zoom = this.view.zoom;
                const panX = this.view.panX;
                const panY = this.view.panY;
                const cellSize = CONFIG.dims.gridSize * zoom;
                
                const w = this.canvas.width;
                const h = this.canvas.height;

                ctx.save();
                ctx.beginPath();
                ctx.strokeStyle = CONFIG.colors.grid;
                ctx.lineWidth = 1;

                // Вычисляем смещение сетки, чтобы она двигалась вместе с панорамой
                // startX/Y - это позиция первой линии на экране
                const startX = panX % cellSize;
                const startY = panY % cellSize;

                // Вертикальные линии
                for (let x = startX; x < w; x += cellSize) {
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, h);
                }

                // Горизонтальные линии
                for (let y = startY; y < h; y += cellSize) {
                    ctx.moveTo(0, y);
                    ctx.lineTo(w, y);
                }
                ctx.stroke();

                // ОСИ НАЧАЛА КООРДИНАТ (0,0)
                // Рисуем их только если они находятся в видимой области
                // Они должны быть поверх обычной сетки и пунктирными
                ctx.beginPath();
                ctx.strokeStyle = '#666';
                ctx.lineWidth = 2;
                ctx.setLineDash([10, 10]);

                if (panX >= -50 && panX <= w + 50) {
                    ctx.moveTo(panX, 0);
                    ctx.lineTo(panX, h);
                }
                if (panY >= -50 && panY <= h + 50) {
                    ctx.moveTo(0, panY);
                    ctx.lineTo(w, panY);
                }
                ctx.stroke();

                // Текст (0,0)
                if (panX > -100 && panX < w && panY > -100 && panY < h) {
                    ctx.fillStyle = '#888';
                    ctx.font = '12px monospace';
                    ctx.setLineDash([]);
                    ctx.fillText("(0, 0)", panX + 5, panY + 15);
                }

                ctx.restore();
            }

             drawConnection(n1, n1Idx, output, oIdx, n2) {
                const start = this.getOutputPos(n1, oIdx);
                
                // Используем вычисляемый центр визуальной высоты целевой ноды
                const end = this.getNodeInputPos(n2);
                
                let color = CONFIG.colors.connection;
                let width = 2;
                
                // ЛОГИКА ЦВЕТОВ
                // 1. Выделение (самый высокий приоритет)
                if (this.isSelectedConnection(output)) {
                    color = CONFIG.colors.selection; // #0078d4
                    width = 4;
                } 
                // 2. Наведение (Hover) - только если не выделено (или можно поверх)
                else if (this.state.hover.connection && this.state.hover.connection.output === output) {
                    color = CONFIG.colors.connectionHover; 
                    width = 4;
                } 
                // 3. Дефолтная
                else if (output.default) {
                    color = CONFIG.colors.connectionDefault; 
                    width = 3;
                }

                const cpOffset = Math.abs(end.x - start.x) * 0.5;
                this.ctx.beginPath();
                this.ctx.strokeStyle = color;
                this.ctx.lineWidth = width;
                this.ctx.moveTo(start.x, start.y);
                this.ctx.bezierCurveTo(start.x + cpOffset, start.y, end.x - cpOffset, end.y, end.x, end.y);
                this.ctx.stroke();

                // Arrow
                this.ctx.beginPath();
                this.ctx.arc(end.x, end.y, 4, 0, Math.PI*2);
                this.ctx.fillStyle = color;
                this.ctx.fill();
            }

            drawNode(node, idx) {
                const zoom = this.view.zoom;
                
                // --- РАЗМЕРЫ ---
                const w = node.w * zoom;
                const hh = CONFIG.dims.headerH * zoom; 
                const rh = CONFIG.dims.rowH * zoom;    
                const fh = CONFIG.dims.footerH * zoom; 
                
                const outputsCount = node.outputs ? node.outputs.length : 0;
                const contentHeightRaw = CONFIG.dims.headerH + (outputsCount * CONFIG.dims.rowH) + CONFIG.dims.footerH + 10;
                const actualH = Math.max(node.h, contentHeightRaw);
                const h = actualH * zoom;

                // Смещение координат (Center Origin)
                const drawX = node.x - (node.w / 2);
                const drawY = node.y - (actualH / 2);

                const pos = Utils.worldToScreen(drawX, drawY, this.view.panX, this.view.panY, zoom);
                const rad = CONFIG.dims.borderRadius * zoom;

                // Цвета
                let borderColor = CONFIG.colors.borderDefault;
                if (this.data.ui.nodes[idx]?.node?.color) {
                    const c = this.data.ui.nodes[idx].node.color;
                    borderColor = `rgb(${c[0]*255}, ${c[1]*255}, ${c[2]*255})`;
                }

                const headerBgColor = node.s ? CONFIG.colors.headerStart : CONFIG.colors.header;
                const outputNameColor = node.s ? CONFIG.colors.headerStart : CONFIG.colors.outputNameDefault;

                // --- ЛОГИКА ВЫДЕЛЕНИЯ ---
                const isSelected = this.isSelected(node); // Используем хелпер множественного выделения

                this.ctx.save();

                // 1. ТЕЛО НОДЫ
                this.ctx.beginPath();
                this.ctx.roundRect(pos.x, pos.y, w, h, rad);
                this.ctx.fillStyle = CONFIG.colors.bgNode;
                this.ctx.fill();

                // 2. ЗАГОЛОВОК
                this.ctx.save();
                this.ctx.clip(); 
                this.ctx.fillStyle = headerBgColor;
                this.ctx.fillRect(pos.x, pos.y, w, hh);
                this.ctx.restore();

                // 3. ОБВОДКА (ИСПРАВЛЕНО)
                this.ctx.beginPath(); // Важно начать новый путь для обводки
                this.ctx.roundRect(pos.x, pos.y, w, h, rad);
                
                if (isSelected) {
                    this.ctx.lineWidth = 3;
                    this.ctx.strokeStyle = CONFIG.colors.selection; // Синий цвет выделения
                } else if (this.state.hover.node === node && this.state.connectionStart) {
                    this.ctx.lineWidth = 3;
                    this.ctx.strokeStyle = CONFIG.colors.connectionHover; // Оранжевый при наведении связи
                } else {
                    this.ctx.lineWidth = 1;
                    this.ctx.strokeStyle = borderColor; // Обычный цвет
                }
                this.ctx.stroke();

                // 4. ТЕКСТ
                this.ctx.textAlign = 'left'; 
                this.ctx.fillStyle = CONFIG.colors.text;
                this.ctx.font = `bold ${Math.max(10, 13 * zoom)}px sans-serif`;
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText(node.c || 'Node', pos.x + 10*zoom, pos.y + hh/2, w - 20);

                // 5. INPUT DOT
                this.ctx.beginPath();
                this.ctx.arc(pos.x, pos.y + h/2, 5*zoom, -Math.PI/2, Math.PI/2);
                this.ctx.fillStyle = '#555';
                this.ctx.fill();

                // 6. OUTPUTS
                if (node.outputs) {
                    const startY = hh + (5 * zoom); 
                    node.outputs.forEach((out, i) => this.drawOutput(node, out, i, pos, startY, outputNameColor));
                }

                // 7. TAGS
                if (node.t) {
                    this.ctx.textAlign = 'left';
                    this.ctx.fillStyle = CONFIG.colors.textDim;
                    this.ctx.font = `italic ${Math.max(9, 11 * zoom)}px sans-serif`;
                    this.ctx.fillText(node.t, pos.x + 10*zoom, pos.y + h - (fh/2) + 2);
                }

                // 8. DISABLED OVERLAY
                if (!node.e) {
                    this.ctx.save();
                    this.ctx.beginPath(); // Начинаем новый путь
                    // Повторяем контур ноды
                    this.ctx.roundRect(pos.x, pos.y, w, h, rad);
                    this.ctx.fillStyle = 'rgba(20, 20, 20, 0.6)'; // Полупрозрачный черный
                    this.ctx.fill();
                    this.ctx.restore();
                }

                this.ctx.restore();
            }

            drawOutput(node, out, idx, pos, startY, nameColor) {
                const rh = CONFIG.dims.rowH * this.view.zoom;
                const yOff = startY + (idx * rh);
                const textY = pos.y + yOff + rh/2;

                // Текст справа
                this.ctx.textAlign = 'right';
                
                let currentX = pos.x + (node.w * this.view.zoom) - (15 * this.view.zoom);
                const fontBaseSize = Math.max(9, 12 * this.view.zoom);
                
                // (Default)
                if (out.default) {
                    this.ctx.font = `bold ${Math.max(8, 10 * this.view.zoom)}px sans-serif`;
                    this.ctx.fillStyle = '#4caf50';
                    const defText = ' (Default)';
                    this.ctx.fillText(defText, currentX, textY);
                    currentX -= this.ctx.measureText(defText).width;
                }

                // Value
                if (out.value) {
                    this.ctx.font = `${fontBaseSize}px sans-serif`;
                    this.ctx.fillStyle = '#ccc';
                    const valText = `: ${out.value}`;
                    this.ctx.fillText(valText, currentX, textY);
                    currentX -= this.ctx.measureText(valText).width;
                }

                // Name
                this.ctx.font = `bold ${fontBaseSize}px sans-serif`;
                this.ctx.fillStyle = nameColor; 
                this.ctx.fillText(out.name, currentX, textY);

                // Точка коннектора
                const cx = pos.x + node.w * this.view.zoom;
                const cy = pos.y + yOff + rh/2;
                
                this.ctx.beginPath();
                this.ctx.arc(cx, cy, CONFIG.dims.dotRadius * this.view.zoom, 0, Math.PI*2);

                // Используем #fff для hover
                if (this.state.hover.output?.output === out) {
                    this.ctx.fillStyle = '#fff'; 
                } else {
                    // Если есть связь - цвет selection (синий), иначе - серый #444
                    this.ctx.fillStyle = out.cnSID ? CONFIG.colors.selection : '#444';
                }

                this.ctx.fill();
                this.ctx.stroke();
                
                this.ctx.textAlign = 'left'; 
            }

            // --- UI GENERATION ---

            generateProperties(node) {
                const p = document.getElementById('properties-panel');
                const val = (v) => (v || '').replace(/"/g, '&quot;');
                
                let html = `
                    <div class="prop-group">
                        <h3>Node Properties</h3>
                        <div class="prop-row"><label>Caption</label><input type="text" class="node-input" data-key="c" value="${val(node.c)}"></div>
                        <div class="prop-row"><label>Tags</label><input type="text" class="node-input" data-key="t" value="${val(node.t)}"></div>
                        <div class="prop-row"><label><input type="checkbox" class="node-check" data-key="e" ${node.e?'checked':''}> Enabled</label></div>
                        <div class="prop-row"><label><input type="checkbox" class="node-check" data-key="s" ${node.s?'checked':''}> Start Node</label></div>
                    </div>
                    <div class="prop-group">
                        <h3>Outputs <button class="btn small" style="float:right" id="prop-add-out">Add</button></h3>
                        <div id="out-list">
                `;

                node.outputs.forEach((o, i) => {
                    html += `
                        <div class="output-item ${o.default?'default':''}">
                            <div class="output-header"><strong>#${i+1}</strong> <button class="btn small danger" data-del-out="${i}">X</button></div>
                            <div class="prop-row"><label>Name</label><input type="text" class="out-input" data-idx="${i}" data-key="name" value="${val(o.name)}"></div>
                            <div class="prop-row"><label>Value</label><textarea class="out-input" data-idx="${i}" data-key="value">${(o.value||'').replace(/\\n/g, '\n')}</textarea></div>
                            <div class="prop-row"><label><input type="checkbox" class="out-check" data-idx="${i}" data-key="enable" ${o.enable?'checked':''}> Enabled</label></div>
                            <div class="prop-row"><label><input type="checkbox" class="out-check" data-idx="${i}" data-key="default" ${o.default?'checked':''}> Default</label></div>
                        </div>
                    `;
                });
                html += '</div></div>';
                p.innerHTML = html;

                // Event Listeners
                p.querySelectorAll('.node-input').forEach(el => el.oninput = e => { node[e.target.dataset.key] = e.target.value; this.render(); });
                p.querySelectorAll('.node-check').forEach(el => el.onchange = e => { 
                    if(e.target.dataset.key === 's' && e.target.checked) this.data.flowchart.nodes.forEach(n=>n.s=false);
                    node[e.target.dataset.key] = e.target.checked; 
                    this.render(); 
                });
                
                p.querySelectorAll('.out-input').forEach(el => el.oninput = e => {
                    let v = e.target.value;
                    if(e.target.tagName === 'TEXTAREA') v = v.replace(/\n/g, '\\n');
                    node.outputs[e.target.dataset.idx][e.target.dataset.key] = v;
                    this.render();
                });
                p.querySelectorAll('.out-check').forEach(el => el.onchange = e => {
                    const idx = e.target.dataset.idx;
                    const key = e.target.dataset.key;
                    if (key === 'default' && e.target.checked) node.outputs.forEach(o => o.default = false);
                    node.outputs[idx][key] = e.target.checked;
                    this.generateProperties(node);
                    this.render();
                });
                
                // --- FIXED: SYNC LOGIC FOR ADD/DELETE OUTPUT ---
                const nodeIdx = this.data.flowchart.nodes.indexOf(node);

                // Внутри generateProperties
                document.getElementById('prop-add-out').onclick = () => {
                    node.outputs.push({ sid: Utils.uuid(), name: "Option", value:"", enable:true, default:false });
                    
                    // Увеличиваем высоту ноды на высоту строки (30px)
                    node.h += CONFIG.dims.rowH; 
                    
                    if (this.data.ui.nodes[nodeIdx]) {
                        this.data.ui.nodes[nodeIdx].outputs.push({ 
                            color: [0,0,0,1], 
                            linkMode: "line", 
                            propertiesBar: {} 
                        });
                    }
                    this.generateProperties(node); this.render();
                };

                p.querySelectorAll('[data-del-out]').forEach(b => b.onclick = e => {
                    const outIdx = parseInt(e.target.dataset.delOut);
                    node.outputs.splice(outIdx, 1);
                    
                    // Уменьшаем высоту, но проверяем минимум
                    const minSize = this.getMinNodeSize(node);
                    node.h = Math.max(minSize.h, node.h - CONFIG.dims.rowH);

                    if (this.data.ui.nodes[nodeIdx] && this.data.ui.nodes[nodeIdx].outputs) {
                        this.data.ui.nodes[nodeIdx].outputs.splice(outIdx, 1);
                    }
                    this.generateProperties(node); this.render();
                });
            }

            showContextMenu(e) {
                const menu = document.getElementById('context-menu');
                const items = [];
                const rect = this.canvas.getBoundingClientRect();
                
                const mx = e.clientX - rect.left;
                const my = e.clientY - rect.top;
                const pasteX = mx;
                const pasteY = my;

                if (this.state.hover.connection) {
                    items.push({ txt: 'Delete Connection', fn: () => { this.state.hover.connection.output.cnSID = null; this.render(); }});
                } else if (this.state.hover.node) {
                    const n = this.state.hover.node;
                    
                    // ЛОГИКА ВЫДЕЛЕНИЯ ПРИ ПКМ:
                    // Если кликнули по ноде, которая НЕ выделена -> выделяем только её
                    if (!this.isSelected(n)) {
                        this.selectSingle(n);
                    }
                    // Если кликнули по уже выделенной -> оставляем выделение группы

                    // Формируем текст для удаления
                    const count = this.state.selection.length;
                    const deleteText = count > 1 ? `Delete ${count} nodes` : 'Delete node';

                    items.push({ txt: 'Copy', fn: () => this.copyNode() }); // Копируем всё выделение
                    items.push({ txt: deleteText, fn: () => this.deleteSelection() }); // Удаляем всё выделение
                    items.push({ txt: '----------------', fn: () => {} });
                    
                    // Действия ниже применяем только к той ноде, над которой курсор (даже если выделено много)
                    // или можно применять ко всем, но для Enable/Start логичнее к конкретной
                    items.push({ txt: n.e ? 'Disable' : 'Enable', fn: () => { n.e = !n.e; this.render(); }});
                    items.push({ txt: 'Set Start', fn: () => { this.data.flowchart.nodes.forEach(x=>x.s=false); n.s=true; this.render(); }});
                } else {
                    items.push({ txt: 'Add Node', fn: () => this.addNode(e.clientX, e.clientY) });
                    if (this.clipboard) {
                        items.push({ txt: 'Paste Node', fn: () => this.pasteNode(pasteX, pasteY) });
                    }
                }

                menu.innerHTML = items.map((i, idx) => {
                    if (i.txt.startsWith('---')) return `<div style="border-top:1px solid #444; margin:4px 0;"></div>`;
                    return `<div class="ctx-item" data-i="${idx}">${i.txt}</div>`;
                }).join('');
                
                menu.style.left = e.clientX + 'px';
                menu.style.top = e.clientY + 'px';
                menu.classList.add('active');
                
                menu.onclick = (evt) => {
                    const idx = evt.target.dataset.i;
                    if(idx !== undefined) { items[idx].fn(); menu.classList.remove('active'); }
                };
            }

            // Открыть окно Help
            openHelp(sectionId) {
                const modal = document.getElementById('help-modal');
                const content = document.getElementById('help-content');
                
                // Проверяем, загрузились ли данные из внешнего файла
                if (typeof HELP_CONTENTS === 'undefined') {
                    content.innerHTML = "<h2>Error</h2><p>Help content file (help-content.js) not found.</p>";
                } else {
                    content.innerHTML = HELP_CONTENTS[sectionId] || "<h2>Error</h2><p>Section not found.</p>";
                }
                
                modal.classList.add('active');
            }

            // --- FILE OPERATIONS ---

            setMode(mode) {
                this.state.mode = mode;
                const ind = document.getElementById('mode-indicator');
                const tb = document.getElementById('toolbar');
                const c = this.canvas;
                
                if (mode === 'edit') {
                    this.data.original = JSON.parse(JSON.stringify(this.data.flowchart)); // Backup
                    ind.textContent = "EDIT MODE"; ind.className = "edit-mode";
                    tb.classList.add('active');
                    c.classList.add('editing');
                    document.getElementById('properties-panel').classList.add('active');
                    document.getElementById('menu-edit-wrapper').style.opacity = "1"; 
                    document.getElementById('btn-toggle-mode').textContent = "Save & Exit";
                    document.getElementById('btn-cancel-edit').style.display = "block";
                    document.getElementById('btn-save').classList.remove('disabled');
                    document.getElementById('edit-hint').style.display = 'block';
                } else {
                    ind.textContent = "VIEW MODE"; ind.className = "view-mode";
                    tb.classList.remove('active');
                    c.classList.remove('editing');
                    document.getElementById('properties-panel').classList.remove('active');
                    document.getElementById('btn-toggle-mode').textContent = "Enter Edit Mode";
                    document.getElementById('btn-cancel-edit').style.display = "none";
                    document.getElementById('btn-save').classList.add('disabled');
                    document.getElementById('edit-hint').style.display = 'none';
                    this.select(null);
                }
            }

            rebuildConnectivity() {
                // Ensure Arrays exist and are clean
                this.data.flowchart.nodes.forEach(n => {
                    n.pnSIDs = []; n.poSIDs = []; n.nodeSIDs = [];
                    n.x = Math.round(n.x); n.y = Math.round(n.y);
                });

                this.data.flowchart.nodes.forEach(src => {
                    src.outputs?.forEach(out => {
                        if (out.cnSID) {
                            const target = this.data.flowchart.nodes.find(n => n.sid === out.cnSID);
                            if (target) {
                                // Logic: Parent adds child ID
                                if(!src.nodeSIDs.includes(target.sid)) src.nodeSIDs.push(target.sid);
                                
                                // Logic: Child adds Parent ID AND Output ID (parallel arrays)
                                target.pnSIDs.push(src.sid);
                                target.poSIDs.push(out.sid);
                            } else {
                                out.cnSID = null; // Clean dead link
                            }
                        }
                    });
                });
            }

            load(json, ui, filename = null) {
                this.data.flowchart = json;
                this.data.ui = ui;
                this.view.zoom = ui.flowchart?.z || 1;
                
                // --- ЛОГИКА ИМЕНИ ---
                // 1. Если передано имя файла (при импорте), используем его как базу, если в JSON нет имени
                if (filename) {
                    // Убираем расширение
                    const nameFromHeader = filename.replace(/\.(json|uistate|miniflow)*$/gi, '');
                    if (!json.name) json.name = nameFromHeader;
                }
                
                // 2. Если имени все еще нет, ставим дефолт
                if (!json.name) json.name = 'flowchart';

                // 3. Обновляем UI
                document.getElementById('filename-display').textContent = json.name;
                // ---------------------

                document.getElementById('zoom-level').textContent = Math.round(this.view.zoom * 100) + '%';
                
                // Center View
                let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
                json.nodes.forEach(n => { minX=Math.min(minX, n.x); minY=Math.min(minY, n.y); maxX=Math.max(maxX, n.x+n.w); maxY=Math.max(maxY, n.y+n.h); });
                if (minX !== Infinity) {
                    this.view.panX = this.canvas.width/2 - ((minX+maxX)/2)*this.view.zoom;
                    this.view.panY = this.canvas.height/2 - ((minY+maxY)/2)*this.view.zoom;
                }
                
                document.getElementById('menu-edit-wrapper').style.opacity = "1";
                document.getElementById('menu-edit-wrapper').style.pointerEvents = "auto";
                this.render();
            }

            // --- MINIFLOW IO ---

            /**
             * Конвертирует текущий граф в формат MiniFlow и скачивает файл.
             */
            exportMiniFlow() {
                // 1. Индексация и поиск корня
                let rootSid = null;
                
                // Ищем стартовую ноду (s=true)
                const startNode = this.data.flowchart.nodes.find(n => n.s);
                if (startNode) {
                    rootSid = startNode.sid;
                } else if (this.data.flowchart.nodes.length > 0) {
                    // Если стартовой нет, берем первую
                    rootSid = this.data.flowchart.nodes[0].sid;
                } else {
                    alert("Граф пуст");
                    return;
                }

                // 2. Генерация читаемых ID (Humanizing IDs)
                const idMap = new Map(); // SID -> StringID
                const usedIds = new Set();

                const generateId = (node) => {
                    // Приоритет: Tag -> Caption -> "node"
                    let base = (node.t || node.c || "node").trim();
                    // Санитизация: только англ буквы, цифры и _, lowercase
                    base = base.toLowerCase().replace(/[^a-z0-9]+/g, '_').replace(/^_+|_+$/g, '');
                    if (!base) base = "node";

                    let candidate = base;
                    let counter = 2;
                    while (usedIds.has(candidate)) {
                        candidate = `${base}_${counter}`;
                        counter++;
                    }
                    usedIds.add(candidate);
                    return candidate;
                };

                this.data.flowchart.nodes.forEach(node => {
                    idMap.set(node.sid, generateId(node));
                });

                // 3. Сборка структуры MiniFlow
                const miniFlow = {
                    root: idMap.get(rootSid),
                    nodes: {}
                };

                this.data.flowchart.nodes.forEach(node => {
                    const strId = idMap.get(node.sid);
                    
                    // Формируем выходы
                    const outputs = (node.outputs || []).map(out => {
                        let nextId = null;
                        if (out.cnSID && idMap.has(out.cnSID)) {
                            nextId = idMap.get(out.cnSID);
                        }
                        return {
                            name: out.name || "Next", // Обязательное поле
                            value: out.value || "",
                            next: nextId
                        };
                    });

                    // Валидация: если выходов нет, добавляем технический заглушку (по ТЗ)
                    if (outputs.length === 0) {
                        outputs.push({ name: "End", value: "", next: null });
                    }

                    miniFlow.nodes[strId] = {
                        caption: node.c || "",
                        tag: node.t || "",
                        outputs: outputs
                    };
                });

                // Скачивание
                const blob = new Blob([JSON.stringify(miniFlow, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = (this.data.flowchart.name || 'miniflow') + '.miniflow.json';
                a.click();
            }

            /**
             * Импортирует JSON в формате MiniFlow, конвертирует в C3 и загружает.
             */
            importMiniFlow(miniJson) {
                if (!miniJson.root || !miniJson.nodes) {
                    alert("Invalid MiniFlow format");
                    return;
                }

                // Шаг 1: Инициализация и Маппинг ID
                const c3Data = {
                    sid: Utils.uuid(),
                    nodes: [],
                    "preset-nodes": { items: [], subfolders: [] },
                    name: "Imported_MiniFlow",
                    w: 30000, h: 30000
                };
                
                // Для UI State создадим дефолтную структуру
                const uiData = { flowchart: { z: 1, sx: 0, sy: 0 }, nodes: [] };

                const sidMap = new Map(); // StringID -> C3 SID
                const nodesByStringId = miniJson.nodes;
                
                // Создаем SID для всех нод заранее
                Object.keys(nodesByStringId).forEach(strId => {
                    sidMap.set(strId, Utils.uuid());
                });

                if (!sidMap.has(miniJson.root)) {
                    alert("Root node not found in nodes list");
                    return;
                }

                // Шаг 2: Генерация нод (Первый проход - создание объектов)
                Object.entries(nodesByStringId).forEach(([strId, miniNode]) => {
                    const c3Sid = sidMap.get(strId);
                    
                    const outputsCount = Array.isArray(miniNode.outputs) ? miniNode.outputs.length : 0;
                    
                    // РАСЧЕТ ВЫСОТЫ ПО СТАНДАРТУ CONSTRUCT 3
                    // Шапка + (строки * 33) + Подвал + небольшой отступ
                    const calcH = CONFIG.dims.headerH + (outputsCount * CONFIG.dims.rowH) + CONFIG.dims.footerH + 10;

                    const c3Node = {
                        sid: c3Sid,
                        pnSIDs: [], poSIDs: [], nodeSIDs: [],
                        x: 0, y: 0, 
                        w: 420,       // Стандартная ширина
                        h: calcH,     // <--- Применяем рассчитанную высоту
                        t: miniNode.tag || "",
                        c: miniNode.caption || strId,
                        s: (strId === miniJson.root),
                        e: true,
                        ty: "dictionary", pi: 0, pr: false, prfsid: null, prfnsid: null,
                        outputs: []
                    };

                    // Создаем выходы (пока без связей)
                    if (Array.isArray(miniNode.outputs)) {
                        c3Node.outputs = miniNode.outputs.map(miniOut => ({
                            sid: Utils.uuid(), // Генерируем ID выхода
                            cnSID: null,       // Заполним на Шаге 3
                            name: miniOut.name || "Next",
                            value: miniOut.value || "",
                            enable: true,
                            default: false,
                            // Временное хранение цели для шага 3
                            _tempNext: miniOut.next 
                        }));
                        // Высота ноды зависит от кол-ва выходов
                        c3Node.h = 100 + (c3Node.outputs.length * 30);
                    }

                    c3Data.nodes.push(c3Node);
                    
                    // Добавляем UI state для ноды
                    uiData.nodes.push({
                        node: { color: [0.8, 0.8, 0.8, 1], propertiesBar: {}, nodeTable: {} },
                        outputs: c3Node.outputs.map(() => ({ color: [0,0,0,1], linkMode: "line", propertiesBar: {} }))
                    });
                });

                // Шаг 3: Линковка (Второй проход - Topology Resolution)
                c3Data.nodes.forEach(sourceNode => {
                    sourceNode.outputs.forEach(output => {
                        const targetStrId = output._tempNext;
                        delete output._tempNext; // Удаляем временное поле

                        if (targetStrId && sidMap.has(targetStrId)) {
                            const targetSid = sidMap.get(targetStrId);
                            const targetNode = c3Data.nodes.find(n => n.sid === targetSid);

                            if (targetNode) {
                                // Прямая связь
                                output.cnSID = targetSid;
                                
                                // Обратные ссылки (Critical for C3)
                                if (!sourceNode.nodeSIDs.includes(targetSid)) {
                                    sourceNode.nodeSIDs.push(targetSid);
                                }
                                targetNode.pnSIDs.push(sourceNode.sid);
                                targetNode.poSIDs.push(output.sid);
                            }
                        }
                    });
                });

                // Шаг 4: Авто-лейаут
                this._miniFlowAutoLayout(c3Data.nodes, sidMap.get(miniJson.root));

                // Загрузка в редактор
                // Передаем имя, сформированное из MiniFlow name (если есть) или дефолтное
                const importedName = c3Data.name || "Imported_MiniFlow";
                c3Data.name = importedName; 
                
                this.load(c3Data, uiData); // filename аргумент здесь не обязателен, т.к. мы уже задали c3Data.name
                // Удаляем старую строку обновления DOM, так как load теперь делает это сам
                // document.getElementById('filename-display').textContent = ... (УДАЛИТЬ ЭТУ СТРОКУ)
                document.getElementById('status-bar').textContent = `Imported ${c3Data.nodes.length} nodes from MiniFlow`;
            }

            /**
             * Простой алгоритм BFS для расстановки нод слоями.
             */
            _miniFlowAutoLayout(nodes, rootSid) {
                // КОНСТАНТЫ ОТСТУПОВ (Сдвигаем вправо и вниз от 0,0)
                const START_X = 300; 
                const START_Y = 300;
                
                const X_STEP = 500;
                const Y_STEP = 300;
                
                const visited = new Set();
                const queue = [{ sid: rootSid, layer: 0 }];
                
                // Отслеживаем следующий свободный Y для каждого слоя (X)
                const layerNextY = {}; 

                // Предварительно сбрасываем координаты
                nodes.forEach(n => { n.x = 0; n.y = 0; });

                while (queue.length > 0) {
                    const { sid, layer } = queue.shift();
                    
                    if (visited.has(sid)) continue;
                    visited.add(sid);

                    const node = nodes.find(n => n.sid === sid);
                    if (!node) continue;

                    // Расчет координат
                    if (layerNextY[layer] === undefined) layerNextY[layer] = 0;
                    
                    // X: Отступ + Слой * Шаг
                    node.x = START_X + (layer * X_STEP);
                    
                    // Y: Отступ + Накопленная высота в слое
                    node.y = START_Y + layerNextY[layer];
                    
                    // Сдвигаем Y для следующей ноды в этом слое
                    layerNextY[layer] += Math.max(node.h, 200) + 50; // Высота ноды + отступ

                    // Добавляем детей в очередь
                    if (node.outputs) {
                        node.outputs.forEach(out => {
                            if (out.cnSID && !visited.has(out.cnSID)) {
                                queue.push({ sid: out.cnSID, layer: layer + 1 });
                            }
                        });
                    }
                }

                // Центрируем камеру редактора на начало графа (с учетом отступа)
                this.view.panX = 50 - (START_X * this.view.zoom); 
                this.view.panY = 50 - (START_Y * this.view.zoom);
                
                // Если зум 1, то просто сбросим в удобную позицию
                if(this.view.zoom === 1) {
                    this.view.panX = 50;
                    this.view.panY = 50;
                }
            }
        }

        // --- APP INITIALIZATION ---

        const app = new FlowchartEditor('canvas');
        
        // 1. Dropdown Menu Logic
        document.querySelectorAll('.menu-item').forEach(m => {
            m.addEventListener('click', e => {
                const drop = m.querySelector('.dropdown');
                if(drop) {
                    const wasActive = drop.style.display === 'block';
                    document.querySelectorAll('.dropdown').forEach(d => d.style.display = 'none');
                    if(!wasActive) drop.style.display = 'block';
                    e.stopPropagation();
                }
            });
        });
        document.addEventListener('click', () => document.querySelectorAll('.dropdown').forEach(d => d.style.display = 'none'));

        // 2. C3 Import Logic (Native & UIState)
        const fileInputC3 = document.getElementById('file-input');
        
        fileInputC3.onchange = async (e) => {
            const files = Array.from(e.target.files);
            const jFile = files.find(f => f.name.endsWith('.json') && !f.name.endsWith('.uistate.json'));
            const uFile = files.find(f => f.name.endsWith('.uistate.json'));
            
            if (jFile && uFile) {
                try {
                    const jData = JSON.parse(await jFile.text());
                    const uData = JSON.parse(await uFile.text());
                    
                    // ПЕРЕДАЕМ jFile.name третьим аргументом
                    app.load(jData, uData, jFile.name);
                    
                    // Строку ниже можно удалить, так как load() теперь обновляет display
                    // document.getElementById('filename-display').textContent = jFile.name;
                    
                    document.getElementById('status-bar').textContent = `${jData.nodes.length} nodes loaded`;
                } catch(err) { alert("Error parsing JSON: " + err.message); }
            } else {
                alert("Please select both .json and .uistate.json files");
            }
            e.target.value = ''; 
        };

        // 3. MiniFlow Import Logic
        const fileInputMini = document.getElementById('file-input-mini');
        
        fileInputMini.onchange = async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            try {
                const text = await file.text();
                const json = JSON.parse(text);
                app.importMiniFlow(json);
            } catch (err) {
                alert("Error reading MiniFlow file: " + err.message);
                console.error(err);
            }
            e.target.value = ''; 
        };

        // 4. Edit Mode Controls
        document.getElementById('btn-toggle-mode').onclick = () => {
            if (app.state.mode === 'view') app.setMode('edit');
            else {
                app.rebuildConnectivity();
                app.setMode('view');
                document.getElementById('status-bar').textContent = 'Changes Saved locally (Memory)';
            }
        };

        document.getElementById('btn-cancel-edit').onclick = () => {
            app.data.flowchart = app.data.original; // Restore from backup
            app.setMode('view');
        };

        // 5. Save / Export C3 Logic
        const saveFile = () => {
            if (!app.data.flowchart) {
                alert("No flowchart data to export");
                return;
            }

            // Перестраиваем связи перед сохранением
            app.rebuildConnectivity();
            
            const download = (content, name) => {
                const a = document.createElement('a');
                a.href = URL.createObjectURL(new Blob([JSON.stringify(content, null, '\t')], {type: 'application/json'}));
                a.download = name; 
                a.click();
            };
            
            const name = app.data.flowchart.name || 'flowchart';
            download(app.data.flowchart, name + '.json');
            download(app.data.ui, name + '.uistate.json');
            
            // Если были в режиме редактирования — выходим (стандартное поведение Save)
            // Если в режиме просмотра (Export) — остаемся как есть
            if (app.state.mode === 'edit') {
                app.setMode('view');
            }
        };

        // 6. View Controls
        document.getElementById('btn-reset-view').onclick = () => { app.view.zoom = 1; app.view.panX=0; app.view.panY=0; app.render(); };

        // 7. Menu Item Bindings (File Menu)

        // -- Stubs --
        document.getElementById('btn-new').onclick = () => alert("New File: Функция пока не реализована (Заглушка)");
        document.getElementById('btn-open').onclick = () => alert("Open File: Функция пока не реализована (Заглушка)");
        
        const saveStubAction = () => alert("Save (Ctrl+S): Локальное сохранение пока не реализовано. Используйте Export.");
        document.getElementById('btn-save-stub').onclick = saveStubAction;
        
        const saveAsStubAction = () => alert("Save As (Shift+Ctrl+S): Функция пока не реализована. Используйте Export.");
        document.getElementById('btn-save-as-stub').onclick = saveAsStubAction;

        // -- Import --
        document.getElementById('btn-import-c3').onclick = () => fileInputC3.click();
        document.getElementById('btn-import-mini').onclick = () => fileInputMini.click();

        // -- Export --
        document.getElementById('btn-export-c3').onclick = () => saveFile(); // Export C3 (JSON + UIState)
        document.getElementById('btn-export-mini').onclick = () => {
             if (!app.data.flowchart) return alert("No flowchart to export");
             app.exportMiniFlow();
        };

        // 8. Toolbar Actions
        const toolAction = (id, fn) => document.getElementById(id).onclick = fn;
        
        toolAction('tool-add-node', () => app.addNode(app.canvas.width/2, app.canvas.height/2));
        toolAction('tool-del-node', () => app.deleteSelection());
        toolAction('tool-add-out', () => document.getElementById('prop-add-out').click());
        
        // Enable/Disable
        toolAction('tool-enable', () => { 
            if (app.state.selectionType === 'node' && app.state.selection.length === 1) { 
                const node = app.state.selection[0];
                node.e = !node.e; 
                app.generateProperties(node); // Обновляем чекбокс в панели
                app.render(); 
            }
        });
        
        // Set Start
        toolAction('tool-start', () => { 
            if (app.state.selectionType === 'node' && app.state.selection.length === 1) { 
                const node = app.state.selection[0];
                // Сбрасываем флаг у всех остальных
                app.data.flowchart.nodes.forEach(n => n.s = false); 
                node.s = true; 
                app.generateProperties(node); 
                app.render(); 
            }
        });
    </script>
</body>
</html>